<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Alamofire网络请求库的使用]]></title>
      <url>%2F2016%2F11%2F11%2FAlamofire%E7%BD%91%E8%B7%AF%E8%AF%B7%E6%B1%82%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Alamofire是目前星星最多的Swift网络请求库,作者和著名的AFNetworking是一个人,接下来介绍一下具体使用方法 准备和介绍支持版本 iOS 9.0+ / macOS 10.11+ / tvOS 9.0+ / watchOS 2.0+Xcode 8.0+Swift 3.0+ 安装我们通常直接用cocoapods安装,省时省力,cocoapods使用可以看上一篇文章 source ‘https://github.com/CocoaPods/Specs.git‘platform :ios, ‘10.0’use_frameworks! target ‘‘ dopod ‘Alamofire’, ‘~&gt; 4.0’end 使用发送请求12import AlamofireAlamofire.request("https://httpbin.org/get") 请求响应12345678910Alamofire.request("https://httpbin.org/get").responseJSON &#123; (response) in print(response.request) // 原请求链接 print(response.response) // 请求响应 print(response.data) // 服务器数据 print(response.result) // 返回结果 if let JSON = response.result.value &#123; print("JSON: \(JSON)") &#125;&#125; Alamofire默认提供5中响应处理1.Response(不推荐)1234func response( queue: DispatchQueue?, completionHandler: @escaping (DefaultDownloadResponse) -&gt; Void) -&gt; Self 对返回的数据不做任何处理123456789Alamofire.request("https://httpbin.org/get").response &#123; (response) in print("Request: \(response.request)") print("Response: \(response.response)") print("error: \(response.error)") if let data = response.data, let utf8Text = String(data: data, encoding: .utf8) &#123; print("Data: \(utf8Text)") &#125;&#125; 2.Response Data1234func responseData( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Data&gt;) -&gt; Void) -&gt; Self 如果返回结果没有出现错误,返回的result是.success和data类型的value1234567Alamofire.request("https://httpbin.org/get").responseData &#123; (response) in print("All Response Info: \(response)") if let data = response.result.value, let utf8Text = String(data: data, encoding: .utf8) &#123; print("Data: \(utf8Text)") &#125;&#125; 3.Response String12345func responseString( queue: DispatchQueue?, encoding: String.Encoding?, completionHandler: @escaping (DataResponse&lt;String&gt;) -&gt; Void) -&gt; Self 如果返回结果没有出现错误,返回的result是.success和String类型的value1234Alamofire.request("https://httpbin.org/get").responseString &#123; response in print("Success: \(response.result.isSuccess)") print("Response String: \(response.result.value)")&#125; 4.Response JSON1234func responseJSON( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Any&gt;) -&gt; Void) -&gt; Self 如果返回结果没有出现错误,返回的result是.success和Any类型的value12345Alamofire.request("https://httpbin.org/get").responseJSON &#123; response in if let json = response.result.value &#123; print("JSON: \(json)") &#125;&#125; 5.Response PropertyList (plist)1234func responsePropertyList( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Any&gt;) -&gt; Void)) -&gt; Self 响应链可以多个响应方式链式调用1234567Alamofire.request("https://httpbin.org/get") .responseString &#123; (response) in print("Response String: \(response.result.value)")&#125; .responseJSON &#123; (response) in print("Response JSON: \(response.result.value)")&#125; 请求队列默认情况下,请求是在主队列中进行的,我们可以自己定制队列1234let utilityQueue = DispatchQueue.global(qos: .utility)Alamofire.request("https://httpbin.org/get").responseJSON(queue: utilityQueue) &#123; (response) in print("Executing response handler on utility queue")&#125; 响应验证手动校验1234567891011Alamofire.request("https://httpbin.org/get") .validate(statusCode: 200..&lt;300) .validate(contentType: ["application/json"]) .responseData &#123; (response) in switch response.result &#123; case .success: print("验证成功") case .failure: print("验证失败") &#125;&#125; 自动校验自动校验状态码范围200…299, 并且该Content-Type与请求头一致12345678Alamofire.request("https://httpbin.org/get").validate().responseJSON &#123; response in switch response.result &#123; case .success: print("校验成功") case .failure(let error): print("校验失败: \(error)") &#125;&#125; HTPP请求方法1234567891011public enum HTTPMethod: String &#123; case options = "OPTIONS" case get = "GET" case head = "HEAD" case post = "POST" case put = "PUT" case patch = "PATCH" case delete = "DELETE" case trace = "TRACE" case connect = "CONNECT"&#125; 这些值可以作为参数传递1234Alamofire.request("https://httpbin.org/get") Alamofire.request("https://httpbin.org/post", method: .post)Alamofire.request("https://httpbin.org/put", method: .put)Alamofire.request("https://httpbin.org/delete", method: .delete) Alamofire.request默认方法参数是 .get 参数编码Alamofire支持3种编码 URL JSON PropertyList 1.URL编码Get请求URL编码参数12345678let parameters: Parameters = ["foo": "bar"]// 下面三种写法等价 Alamofire.request("https://httpbin.org/get", parameters: parameters) // encoding defaults to `URLEncoding.default`Alamofire.request("https://httpbin.org/get", parameters: parameters, encoding: URLEncoding.default)Alamofire.request("https://httpbin.org/get", parameters: parameters, encoding: URLEncoding(destination: .methodDependent))// https://httpbin.org/get?foo=bar Post请求URL编码参数12345678910111213141516let parameters: Parameters = [ "foo": "bar", "baz": ["a", 1], "qux": [ "x": 1, "y": 2, "z": 3 ]]// 下面三种写法等价 Alamofire.request("https://httpbin.org/post", parameters: parameters)Alamofire.request("https://httpbin.org/post", parameters: parameters, encoding: URLEncoding.default)Alamofire.request("https://httpbin.org/post", parameters: parameters, encoding: URLEncoding.httpBody)// HTTP body: foo=bar&amp;baz[]=a&amp;baz[]=1&amp;qux[x]=1&amp;qux[y]=2&amp;qux[z]=3 2.JSON编码123456789101112let parameters: Parameters = [ "foo": [1,2,3], "bar": [ "baz": "qux" ]]// 两种写法等价Alamofire.request("https://httpbin.org/post", method: .post, parameters: parameters, encoding: JSONEncoding.default)Alamofire.request("https://httpbin.org/post", method: .post, parameters: parameters, encoding: JSONEncoding(options: []))// HTTP body: &#123;"foo": [1, 2, 3], "bar": &#123;"baz": "qux"&#125;&#125; 3.Property List编码当ParameterEncoding类型不能满足需求时,可以创建自定义编码1234567891011121314151617struct JSONStringArrayEncoding: ParameterEncoding &#123; private let array: [String] init(array: [String]) &#123; self.array = array &#125; func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -&gt; URLRequest &#123; var urlRequest = urlRequest.urlRequest let data = try JSONSerialization.data(withJSONObject: array, options: []) if urlRequest.value(forHTTPHeaderField: "Content-Type") == nil &#123; urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type") &#125; urlRequest.httpBody = data return urlRequest &#125;&#125; HTTP请求头12345678let headers: HTTPHeaders = [ "Authorization": "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==", "Accept": "application/json"]Alamofire.request("https://httpbin.org/headers", headers: headers).responseJSON &#123; response in debugPrint(response)&#125; 认证认证是由系统框架层处理URLCredential和URLAuthenticationChallenge。 1.基本认证1234567let user = "user"let password = "password"Alamofire.request("https://httpbin.org/basic-auth/\(user)/\(password)") .authenticate(user: user, password: password) .responseJSON &#123; (response) in debugPrint(response)&#125; 放在请求头中也能达到该效果123456789101112let user = "user"let password = "password"var headers: HTTPHeaders = [:]if let authorizationHeader = Request.authorizationHeader(user: user, password: password) &#123; headers[authorizationHeader.key] = authorizationHeader.value&#125;Alamofire.request("https://httpbin.org/basic-auth/user/password", headers: headers) .responseJSON &#123; response in debugPrint(response)&#125; 2.URLCredential认证123456789let user = "user"let password = "password"let credential = URLCredential(user: user, password: password, persistence: .forSession)Alamofire.request("https://httpbin.org/basic-auth/\(user)/\(password)") .authenticate(usingCredential: credential) .responseJSON &#123; response in debugPrint(response)&#125; 下载数据到文件夹12345Alamofire.download("https://httpbin.org/image/png").responseData &#123; (response) in if let data = response.result.value &#123; let image = UIImage(data: data) &#125;&#125; 下载到执行文件夹中1234567891011121314let destination: DownloadRequest.DownloadFileDestination = &#123; _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent("pig.png") return (fileURL, [.removePreviousFile, .createIntermediateDirectories])&#125;Alamofire.download(urlString, to: destination).response &#123; response in print(response) if response.error == nil, let imagePath = response.destinationURL?.path &#123; let image = UIImage(contentsOfFile: imagePath) &#125;&#125; 下载到建议的目录下12let destination = DownloadRequest.suggestedDownloadDestination(for: .documentDirectory)Alamofire.download("https://httpbin.org/image/png", to: destination) 下载进度123456789Alamofire.download("https://httpbin.org/image/png") .downloadProgress &#123; progress in print("下载进度: \(progress.fractionCompleted)") &#125; .responseData &#123; response in if let data = response.result.value &#123; let image = UIImage(data: data) &#125;&#125; 来个线程1234567891011let utilityQueue = DispatchQueue.global(qos: .utility)Alamofire.download("https://httpbin.org/image/png") .downloadProgress(queue: utilityQueue) &#123; progress in print("Download Progress: \(progress.fractionCompleted)") &#125; .responseData &#123; response in if let data = response.result.value &#123; let image = UIImage(data: data) &#125;&#125; 恢复下载有时候我们在下载的时候可能会取消或者中断了,这时候下次可能需要接着下载,这时候就需要恢复下载1234567891011121314151617181920212223242526272829303132class ImageRequestor &#123; private var resumeData: Data? private var image: UIImage? func fetchImage(completion: (UIImage?) -&gt; Void) &#123; guard image == nil else &#123; completion(image) ; return &#125; let destination: DownloadRequest.DownloadFileDestination = &#123; _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent("pig.png") return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) &#125; let request: DownloadRequest if let resumeData = resumeData &#123; request = Alamofire.download(resumingWith: resumeData) &#125; else &#123; request = Alamofire.download("https://httpbin.org/image/png") &#125; request.responseData &#123; response in switch response.result &#123; case .success(let data): self.image = UIImage(data: data) case .failure: self.resumeData = response.resumeData &#125; &#125; &#125;&#125; 上传文件1.上传Data文件1234let imageData = UIImagePNGRepresentation(image)!Alamofire.upload(imageData, to: "https://httpbin.org/post").responseJSON &#123; response in debugPrint(response)&#125; 2.上传File1234let fileURL = Bundle.main.url(forResource: "video", withExtension: "mov")!Alamofire.upload(fileURL, to: "https://httpbin.org/post").responseJSON &#123; response in debugPrint(response)&#125; 3.上传多文件1234567891011121314151617Alamofire.upload( multipartFormData: &#123; multipartFormData in multipartFormData.append(ImageURL1, withName: "image1") multipartFormData.append(ImageURL2, withName: "image2") &#125;, to: "https://httpbin.org/post", encodingCompletion: &#123; encodingResult in switch encodingResult &#123; case .success(let upload, _, _): upload.responseJSON &#123; response in debugPrint(response) &#125; case .failure(let encodingError): print(encodingError) &#125; &#125;) 4.上传进度123456789101112let fileURL = Bundle.main.url(forResource: "video", withExtension: "mov")!Alamofire.upload(fileURL, to: "https://httpbin.org/post") .uploadProgress &#123; progress in print("上传进度: \(progress.fractionCompleted)") &#125; .downloadProgress &#123; progress in print("下载进度: \(progress.fractionCompleted)") &#125; .responseJSON &#123; response in debugPrint(response)&#125; 证书验证12345let serverTrustPolicy = ServerTrustPolicy.pinCertificates( certificates: ServerTrustPolicy.certificatesInBundle(), validateCertificateChain: true, validateHost: true) 基本用法先介绍到这里,下篇将仔细整理HTTPS以及验证证书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GCD Swift3.0]]></title>
      <url>%2F2016%2F11%2F09%2FGCD-Swift3-0%2F</url>
      <content type="text"><![CDATA[Swift3.0之后GCD的写法是越来越简单,以下是平时项目开发中可能会遇到的多线程操作,现在整理一起方便以后查阅. 基本分类队列执行任务分为 同步:在当前线程中执行,执行完才会执行下一条命令,会阻塞当前线程异步:在另一个线程中执行,下一条命令不许要等该线程执行完,不会阻塞当前线程 队列分类 串行队列:让任务一个接一个的执行并发队列:多个任务同时进行,只有在异步函数下才有效 创建分类创建串行队列1let serial = DispatchQueue(label: "serialqueue1") 创建并行队列12345let concurrent = DispatchQueue(label: "concurrentqueue1", qos: .userInitiated, attributes: .concurrent, autoreleaseFrequency: .workItem, target: nil) 参数说明 1.label 队列名称2.qos 设置优先级 (默认是 default) .background : 后台(非常耗时的不重要的操作放在这里,执行完调用主线程) .utility : 低 .default : 正常的 .userInitiated : 高(不要放太耗时的操作) .userInteractive : 用户交互(跟主线程一样) .unspecified : 不指定 3.attributes 队列类型 .concurrent : 并行队列 .initiallyInactive : 与线程优先级有关 获取系统队列获取系统存在的全局队列,可设置优先级1let globalQueue = DispatchQueue.global(qos: .default) 获取系统主线程,跟UI有关的操作需要放在主线程中执行1let mainQueue = DispatchQueue.main 队列操作添加任务到队列中异步123456DispatchQueue.global(qos: .default).async &#123; print("耗时操作") DispatchQueue.main.async &#123; print("耗时操作完,回调主线程刷新界面") &#125;&#125; 同步12345678// 全局线程DispatchQueue.global(qos: .default).sync &#123; print("我在全局队列中执行同步操作")&#125;// 主线程执行同步会引起死锁DispatchQueue.main.sync &#123; print("我在主线程中执行同步操作")&#125; 暂停、继续队列1234567891011let concurrentQueue = DispatchQueue(label: "queue2", attributes: .concurrent)concurrentQueue.async &#123; (1...100000000000000000).forEach(&#123; (index) in print(index) &#125;)&#125;// 暂停concurrentQueue.suspend()sleep(2)// 继续concurrentQueue.resume() 延时操作123DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) &#123; print("我延时两秒执行")&#125; 只执行一次12345678910private var once1:Void = &#123; //只执行一次 print("once1")&#125;()private lazy var once2:String = &#123; //只执行一次，可用于创建单例 print("once2") return "once2"&#125;() Group的用法1234567891011121314151617181920212223// 获取全局队列let queue = DispatchQueue.global()// 创建grouplet group = DispatchGroup()// 并发queue.async(group: group, qos: .default, flags: .barrier) &#123; sleep(2) print("我是第一吗")&#125;queue.async(group: group, qos: .default, flags: .barrier) &#123; sleep(2) print("我是第二吗")&#125;queue.async(group: group, qos: .default, flags: .barrier) &#123; sleep(2) print("我是第三吗")&#125;// 不阻塞主线程group.notify(queue: queue) &#123; print("大家都执行完毕了吧")&#125;如果有多个并发队列在一个组里，我们想在这些操作执行完了再继续，调用waitgroup.wait() 指定多次Block到队列中123456789let queue2 = DispatchQueue.global()queue2.async &#123; DispatchQueue.concurrentPerform(iterations: 3, execute: &#123; (index) in print(index) &#125;) DispatchQueue.main.async &#123; print("执行完毕,在主线程中刷新") &#125;&#125; 信号量为了线程安全的统计数量，我们会使用信号量作计数。1234567891011let queue3 = DispatchQueue.global(qos: .default)let semaphore = DispatchSemaphore(value: 1)(1...1000).forEach &#123; (index) in queue3.async &#123; // 信号量减一, semaphore.wait() print(index) // 信号量加一 semaphore.signal() &#125;&#125; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swift3.0新特性]]></title>
      <url>%2F2016%2F11%2F07%2Fswift3-0%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
      <content type="text"><![CDATA[自 Swift 开源以来，Swift 的开发与演变已经完全由社区和核心团队所共同主导，它们在 Swift 3 当中为我们带来了巨大的变化和改进，而这正是我们所需要详细了解的 彻底移除在 Swift 2.2 就已经弃用的特性弃用 ++ 与 – 操作符过去我们可以使用 ++ 与 – 操作符来实现自增自减，现已废弃。12345var i = 0i++++ii----i 可以使用复合加法运算（+=）与减法运算（-=），或者使用普通的加法运算（+）与减法运算（-）实现同样的功能。12345678//使用复合加法运算（+=）与减法运算（-=）var i = 0i += 1i -= 1//使用普通的加法运算（+）与减法运算（-）i = i + 1i = i - 1 废除C语言风格的for循环我们过去可能习惯下面风格的 for 循环，现在也已废弃。123for var i=1; i&lt;100; i++ &#123;print("\(i)")&#125; 现在可以使用 for-in 循环，或者使用 for-each 加闭包的写法实现同样的功能。123456789//for-in循环for i in 1...10 &#123;print(i)&#125;//for-each循环(1...10).forEach &#123;print($0)&#125; 移除函数参数的 var 标记在 Swift 函数中，参数默认是常量。过去可以在参数前加关键字 var 将其定义为变量，这样函数内部就可以对该参数进行修改（外部的参数任然不会被修改）。123456var age = 22add(age)func add(var age:Int) &#123;age += 1&#125; 现在这种做法已经被废弃，Swift 3 不再允许开发者这样来将参数标记为变量了。 所有函数参数都必须带上标签过去如果一个函数有多个参数，调用的时候第一个参数无需带标签，而从第二个参数开始，必须要带标签。12345let number = additive(8, b: 12)func additive(a:Int, b:Int) -&gt; Int&#123; return a + b&#125; 现在为了确保函数参数标签的一致性，所有参数都必须带上标签。12345let number = additive(a: 8, b: 12)func additive(a:Int, b:Int) -&gt; Int&#123; return a + b&#125; 这个变化可能会造成我们的项目代码要进行较大的改动，毕竟涉及的地方很多。所以苹果又给出了一种不用给第一个参数带标签的解决方案。即在第一个参数前面加上一个下划线。（不过这个只是方便我们代码从 Swift2 迁移到 Swift3 的一个折中方案，可以的话还是建议将所有的参数都带上标签。）12345let number = additive(8, b: 12)func additive(_ a:Int, b:Int) -&gt; Int&#123; return a + b&#125; 函数声明和函数调用都需要括号来包括参数我们可以使用函数类型作为参数 ，对于一个参数是函数、返回值也是函数的函数。原来我们可能会这么写：1func g(a: Int -&gt; Int) -&gt; Int-&gt;Int &#123; ... &#125; 当这样非常难以阅读，很难看出参数在哪里结束，返回值又从哪里开始。在 Swift 3 中变成这么定义这个函数：1func g(a:(Int) -&gt; Int) -&gt; (Int) -&gt; Int &#123; ... &#125; Selector 不再允许使用 String假设我们给按钮添加一个点击事件响应，点击后执行 tapped 函数。以前可以这么写：1button.addTarget(responder, action: "tapped", forControlEvents: .TouchUpInside) 但由于按钮的 selector 写的是字符串。如果字符串拼写错了，那程序会在运行时因找不到相关方法而崩溃。所以 Swift 3 将这种写法废除，改成 #selecor()。这样就将允许编译器提前检查方法名的拼写问题，而不用再等到运行时才发现问题。1button.addTarget(self, action:#selector(tapped), for:.touchUpInside) Swift 3 的新特性内联序列函数sequenceSwift 3 新增了两个全局函数：sequence(first: next:) 和 sequence(state: next:)。使用它们可以返回一个无限序列。下面是一个简单的使用样例123456789// 从某一个树节点一直向上遍历到根节点for node in sequence(first: leaf, next: &#123; $0.parent &#125;) &#123; // node is leaf, then leaf.parent, then leaf.parent.parent, etc.&#125;// 遍历出所有的2的n次方数（不考虑溢出）for value in sequence(first: 1, next: &#123; $0 * 2 &#125;) &#123; // value is 1, then 2, then 4, then 8, etc.&#125; key-path不再只能使用String这个是用在键值编码（KVC）与键值观察（KVO）上的我们还是可以继续使用 String 类型的 key-Path：1234567891011121314151617//用户类class User: NSObject&#123; var name:String = "" //姓名 var age:Int = 0 //年龄&#125;//创建一个User实例对象let user1 = User()user1.name = "hangge"user1.age = 100//使用KVC取值let name = user1.value(forKey: "name")print(name)//使用KVC赋值user1.setValue("hangge.com", forKey: "name") 但建议使用新增的 #keyPath() 写法，这样可以避免我们因为拼写错误而引发问题。123456//使用KVC取值let name = user1.value(forKeyPath: #keyPath(User.name))print(name)//使用KVC赋值user1.setValue("hangge.com", forKeyPath: #keyPath(User.name)) Foundation 去掉 NS 前缀比如过去我们使用 Foundation 相关类来对文件中的 JSON 数据进行解析，这么写：12345let file = NSBundle.mainBundle().pathForResource("tutorials", ofType: "json")let url = NSURL(fileURLWithPath: file!)let data = NSData(contentsOfURL: url)let json = try! NSJSONSerialization.JSONObjectWithData(data!, options: [])print(json) 在 Swift 3 中，将移除 NS 前缀，就变成了：12345let file = Bundle.main.path(forResource: "tutorials", ofType: "json")let url = URL(fileURLWithPath: file!)let data = try! Data(contentsOf: url)let json = try! JSONSerialization.jsonObject(with: data)print(json) 除了M_PI 还有 .pi在过去，我们使用 M_PI 常量来表示 π。所以根据半径求周长代码如下：12let r = 3.0let circumference = 2 * M_PI * r 在 Swift 3 中，π 提供了 Float，Double 与 CGFloat 三种形式（Float.pi、Double.pi、CGFloat.pi），所以求周长还可以这么写：123456et r = 3.0let circumference = 2 * Double.pi * r//我们还可以将前缀省略，让其通过类型自动推断let r = 3.0let circumference = 2 * .pi * r 简化GCD的写法过去写法采用 C 语言的风格，初学者可能会不大适应。比如创建一个简单的异步线程1234let queue = dispatch_queue_create("Swift 2.2", nil)dispatch_async(queue) &#123; print("Swift 2.2 queue")&#125; Swift 3 取消了这种冗余的写法，而采用了更为面向对象的方式：1234let queue = DispatchQueue(label: "Swift 3")queue.async &#123; print("Swift 3 queue")&#125; Core Graphics的写法也更加面向对象化Core Graphics 是一个相当强大的绘图框架，但是和 GCD 一样，它原来的 API 也是 C 语言风格的。比如我们要创建一个 view，其内部背景使用 Core Graphics 进行绘制（红色边框，蓝色背景）。过去我们这么写：123456789101112131415class View: UIView &#123; override func drawRect(rect: CGRect) &#123; let context = UIGraphicsGetCurrentContext() let blue = UIColor.blueColor().CGColor CGContextSetFillColorWithColor(context, blue) let red = UIColor.redColor().CGColor CGContextSetStrokeColorWithColor(context, red) CGContextSetLineWidth(context, 10) CGContextAddRect(context, frame) CGContextDrawPath(context, .FillStroke) &#125;&#125;let frame = CGRect(x: 0, y: 0, width: 100, height: 50)let aView = View(frame: frame) 在 Swift 3 中改进了写法，只要对当前画布上下文解包，之后的所有绘制操作就都基于解包对象。123456789101112131415161718class View: UIView &#123; override func draw(_ rect: CGRect) &#123; guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125; let blue = UIColor.blue.cgColor context.setFillColor(blue) let red = UIColor.red.cgColor context.setStrokeColor(red) context.setLineWidth(10) context.addRect(frame) context.drawPath(using: .fillStroke) &#125;&#125;let frame = CGRect(x: 0, y: 0, width: 100, height: 50)let aView = View(frame: frame) 新增的访问控制关键字：fileprivate、open在 Swift 3 中在原有的 3 个访问控制关键字 private、public、internal 外。又添加了2个新关键字 fileprivate、open。它们可以看成是对原来 private 和 public 的进一步细分 一些语法的修改数组排序：sort()与sorted()过去数组排序的两个方法：sortInPlace() 和 sort()，现在分别改名成 sort() 和 sorted()sort() 是直接对目标数组进行排序。sorted() 是返回一个排序后的数组，原数组不变。12345678var array1 = [1, 5, 3, 2, 4]array1.sort()print(array1) //[1, 2, 3, 4, 5]var array2 = [1, 5, 3, 2, 4]let sortedArray = array2.sorted()print(array2) //[1, 5, 3, 2, 4]print(sortedArray) //[1, 2, 3, 4, 5] reversed()与enumerated()过去 reverse() 方法实现数组反转，enumerate() 方法实现遍历。现这两个方法都加上 ed 后缀（reversed、enumerated）12345678for i in (1...10).reversed() &#123;print(i)&#125;let array = [1, 5, 3, 2, 4]for (index, value) in array.enumerated() &#123;print("\(index + 1) \(value)")&#125; CGRect、CGPoint、CGSize过去的 CGRectMake、CGPointMake、CGSizeMake 已废弃。现改用 CGRect、CGPoint、CGSize 代替。123456789//Swift 2let frame = CGRectMake(0, 0, 20, 20)let point = CGPointMake(0, 0)let size = CGSizeMake(20, 20)//Swift 3let frame = CGRect(x: 0, y: 0, width: 20, height: 20)let point = CGPoint(x: 0, y: 0)let size = CGSize(width: 20, height: 20) 移除了API中多余的单词XCPlaygroundPage.currentPage 改为 PlaygroundPage.currentbutton.setTitle(forState) 改为 button.setTitle(for)button.addTarget(action, forControlEvents) 改为 button.addTarget(action, for) arr.minElement() 改为 arr.min()arr.maxElement() 改为 arr.max()attributedString.appendAttributedString(anotherString) 改为 attributedString.append(anotherString)names.insert(“Jane”, atIndex: 0) 改为 names.insert(“Jane”, at: 0) NSBundle.mainBundle() 改为 Bundle.mainUIDevice.currentDevice() 改为 UIDevice.currentNSData(contentsOfURL) 改为 Data(contentsOf)NSJSONSerialization.JSONObjectWithData() 改为 JSONSerialization.jsonObject(with)UIColor.blueColor() 改为 UIColor.blue 枚举成员变成小写字母开头Swift 3 将枚举成员当做属性来看，所以现在使用小写字母开头而不是以前的大写字母。1234.system //过去是：.System.touchUpInside //过去是：.TouchUpInside.fillStroke //过去是：.FillStroke.cgColor //过去是：.CGColor @discardableResult在 Swift 3 中，如果一个方法有返回值。而调用的时候没有接收该方法的返回值，Xcode 会报出警告，告诉你这可能会存在潜在问题。1234567891011121314151617181920import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() printMessage(message: "Hello Swift 3!") &#125; @discardableResult func printMessage(message: String) -&gt; String &#123; let outputMessage = "Output : \(message)" return outputMessage &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() &#125;&#125; 以上整理来自航歌个人博客,查看更全的Swift3.0新特性可访问realm]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[企业分发的项目安装使用方法]]></title>
      <url>%2F2016%2F11%2F05%2F%E4%BC%81%E4%B8%9A%E9%A1%B9%E7%9B%AE%E4%BF%A1%E4%BB%BB%2F</url>
      <content type="text"><![CDATA[由于之前做的项目有的是用企业证书打包的,走的是企业分发的通道,iOS9之后打开的时候不在有信任这一选项,所以很多用户一时还不知道该怎么设置,这里介绍一下打开企业应用的流程 原因 苹果的企业开发证书，可以不经app store,直接发布到自己的网站上。其他人可以直接下载安装。但前提要用苹果自带的浏览器（safari)才能下载，其他浏览器不能识别该协议。 由于iOS9增强了企业版开发者证书的验证规则，因此iOS9需要用户手动信任企业证书，才能正常使用。默认情况下，打开企业证书打包的app是这样的情况。 企业证书验证步骤介绍 “设置”-&gt;”通用”-&gt;”描述文件”-&gt;［找到对应的证书］-&gt;信用证书 设置步骤打开“设置” 设置 找到“通用”－“描述文件” 通用－描述文件选择对应的企业证书，如以下企业证书： 信用此证书 重新打开]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[卡片动画]]></title>
      <url>%2F2016%2F11%2F03%2F%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[现在许多应用的信息展示用到了卡片式的样式,开源代码也很多了,其主要是应用了UICollectionView的布局定制,自定义UICollectionViewFlowLayout实现的,这里具体来记录一下常见的实现过程 添加UICollectionView到界面上定义Collectionview12345678910111213func createCollectionView() &#123; collectionView = UICollectionView(frame: CGRect(x:0, y:100, width:SCREEN_WIDTH, height:200), collectionViewLayout: layout) collectionView.backgroundColor = UIColor.clear collectionView.collectionViewLayout = layout // 不显示水平方向的横条 collectionView.showsHorizontalScrollIndicator = false // 实现代理 collectionView.delegate = self collectionView.dataSource = self collectionView.register(DNViewCell.self, forCellWithReuseIdentifier: cellIdentifier) collectionView.reloadData() self.view.addSubview(collectionView)&#125; 懒加载自定义的UICollectionViewFlowLayout(稍后实现)12345678910111213lazy var layout: DNFlowLayout = &#123; let lo = DNFlowLayout() // 滚动方向 水平 lo.scrollDirection = .horizontal // 最小行间距 lo.minimumLineSpacing = 20 // 上下左右间距 lo.sectionInset = UIEdgeInsetsMake(0, LAYOUT_INSET, 0, LAYOUT_INSET) // cell大小 lo.itemSize = CGSize(width: CELL_WIDTH, height: CELL_WIDTH) return lo&#125;() 实现CollectionView代理123456789101112131415extension ViewController: UICollectionViewDelegate, UICollectionViewDataSource &#123; func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return 20; &#125; func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; let cell = self.collectionView.dequeueReusableCell(withReuseIdentifier: cellIdentifier, for: indexPath) as! DNViewCell cell.contentView.backgroundColor = UIColor.red return cell &#125; func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123; print(indexPath.item) &#125;&#125; 通过上述代码可以实现简单的collectionview展示如下 接下来,我们要实现过度动画效果,通过定制UICollectionViewFlowLayout来实现,借鉴借鉴别人写的就偷偷懒了 自定义UICollectionViewFlowLayout12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class DNFlowLayout: UICollectionViewFlowLayout &#123; override func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint) -&gt; CGPoint &#123; // 当前处理器能处理的最大浮点数 var offsetAdjustment = CGFloat(MAXFLOAT) // collectionView落在屏幕中点的x坐标 let horizontalCenter = proposedContentOffset.x + (self.collectionView!.bounds.width / 2.0) let targetRect = CGRect(x: proposedContentOffset.x, y: 0.0, width: self.collectionView!.bounds.size.width, height: self.collectionView!.bounds.size.height) // 目标区域中包含的cell let array = super.layoutAttributesForElements(in: targetRect) as [UICollectionViewLayoutAttributes]! for layoutAttributes in array!&#123; let itemHorizontalCenter = layoutAttributes.center.x //ABS求绝对值 if(abs(itemHorizontalCenter-horizontalCenter) &lt; abs(offsetAdjustment))&#123; // 比较谁离中心点更近 offsetAdjustment = itemHorizontalCenter-horizontalCenter &#125; &#125; // 返回collectionView最终停留的位置 return CGPoint(x: proposedContentOffset.x + offsetAdjustment, y: proposedContentOffset.y) &#125; // 垂直缩放除以系数 let ActiveDistance : CGFloat = 350 // 缩放系数 越大缩放越大 let ScaleFactor : CGFloat = 0.25 override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? &#123; // rect范围内的cell视图 let array = super.layoutAttributesForElements(in: rect) var visibleRect = CGRect() visibleRect.origin = self.collectionView!.contentOffset visibleRect.size = self.collectionView!.bounds.size for attributes in array!&#123; let distance = visibleRect.midX - attributes.center.x let normalizedDistance = distance/ActiveDistance let zoom = 1 - ScaleFactor*(abs(normalizedDistance)) let alpha = 1 - abs(normalizedDistance) // SX：X轴缩放 SY：Y轴缩放 attributes.transform3D = CATransform3DMakeScale(1.0, zoom, 1.0) attributes.alpha = alpha attributes.zIndex = 1 &#125; return array &#125; override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -&gt; Bool &#123; // 滑动放大缩小 需要实时刷新layout return true &#125;&#125; 实现后的效果 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[横竖屏控制]]></title>
      <url>%2F2016%2F11%2F01%2F%E6%A8%AA%E7%AB%96%E5%B1%8F%E6%8E%A7%E5%88%B6%2F</url>
      <content type="text"><![CDATA[许多应用都支持横竖屏旋转,因此就有了每个界面需要能够自由控制界面方向的需求,我们以最常见的Navi+Tabbar为例,实现该种需求 导航控制器中设置12345678910111213class DNNavigationController: UINavigationController &#123; override var shouldAutorotate: Bool &#123; return self.topViewController!.shouldAutorotate &#125; override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123; return self.topViewController!.supportedInterfaceOrientations &#125; override var preferredStatusBarStyle: UIStatusBarStyle &#123; return self.topViewController!.preferredStatusBarStyle &#125;&#125; TabBar设置123456789class DNTabBarViewController: UITabBarController &#123; override var shouldAutorotate: Bool &#123; return self.selectedViewController!.shouldAutorotate &#125; override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123; return (self.selectedViewController?.supportedInterfaceOrientations) ?? .all &#125;&#125; 在要控制的界面中实现 现在大部分应用界面还都是以竖屏为主,最好定义一个ViewController的基类,在需要支持横竖屏的类里再重写改方法 1234567override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123; return .portrait&#125;override var shouldAutorotate: Bool &#123; return true&#125; 问题 只是实现这些的话,在plus手机中可能会出现方向混乱的情况,尤其是手机横屏的时候进入,但是界面只支持竖屏,解决这一问题我们需要在应用初始化的时候定义方向,一定要在创建window之前定义 12345678910func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; // 初始化屏幕方向 UIApplication.shared.setStatusBarOrientation(.portrait, animated: true) // 创建window self.window = UIWindow(frame: UIScreen.main.bounds) self.window?.makeKeyAndVisible() self.window?.backgroundColor = UIColor.white return true&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[textField输入中文文字下沉问题]]></title>
      <url>%2F2016%2F10%2F31%2FtextField%E9%97%AE%E9%A2%98001%2F</url>
      <content type="text"><![CDATA[当我们用storyboard创建一个textfield的时候,输入中文时文字会往下偏移,输入英文时一切正常 解决其实很简单,设置一下textfield的clearButtonMode就行了1textField.clearButtonMode = .whileEditing]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode8注释失效]]></title>
      <url>%2F2016%2F10%2F29%2FXcode8%E6%B3%A8%E9%87%8A%E5%A4%B1%E6%95%88%2F</url>
      <content type="text"><![CDATA[每次升级Xcode对于插件来说都是一次灾难,总是会失效,这次Xcode8也不例外,不过类似VVDocument注释功能被苹果自己添加进来了,不用再用第三方的了 Xcode8自带的注释快捷键是单行注释: command + /多行注释: command + option + / 下图绿框中的为注释相关设置 如何修改快捷键如果觉得默认注释快捷键不是自己喜欢的组合,则可以自己改,比如我把它修改成shift + / 其是就是 ? 问题在使用注释快捷键的时候可能会弹出警告如下图这个通常是xcode不知道你要给谁添加注释,比如你要给一个方法添加注释,但是光标位置跟方法空了一行等]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法 Swift]]></title>
      <url>%2F2016%2F10%2F27%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-Swift%2F</url>
      <content type="text"><![CDATA[在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法,这里总结几个常用算法的写法,包括冒泡排序,快速排序,插入排序,选择排序. 冒泡排序12345678910111213func bubbleSort&lt;T: Comparable&gt; (oArr: [T]) -&gt; [T] &#123; var arr = oArr for outerIndex in (1...arr.count - 1).reversed() &#123; for innerIndex in 0..&lt;outerIndex &#123; if arr[innerIndex] &gt; arr[innerIndex + 1] &#123; let temp = arr[innerIndex] arr[innerIndex] = arr[innerIndex + 1] arr[innerIndex + 1] = temp &#125; &#125; &#125; return arr&#125; 快速排序123456789101112131415161718extension Array &#123; var decompose : (head: Element, tail: [Element])? &#123; return (count &gt; 0) ? (self[0], Array(self[1..&lt;count])) : nil &#125;&#125;func quickSort&lt;T: Comparable&gt; (oArr: [T]) -&gt; [T] &#123; let arr = oArr if let (pivot, rest) = arr.decompose &#123; let lesser = rest.filter &#123; $0 &lt; pivot &#125; let greater = rest.filter &#123; $0 &gt;= pivot &#125; let les = quickSort(oArr: lesser) let gre = quickSort(oArr: greater) return les + [pivot] + gre &#125; else &#123; return [] &#125;&#125; 插入排序12345678910111213func insertionSort&lt;T: Comparable&gt; (oArr: [T]) -&gt; [T] &#123; var arr = oArr for outerIndex in 1..&lt;arr.count &#123; let temp = arr[outerIndex] var innerIndex = outerIndex while innerIndex &gt; 0 &amp;&amp; arr[innerIndex - 1] &gt;= temp &#123; arr[innerIndex] = arr[innerIndex - 1] innerIndex -= 1 &#125; arr[innerIndex] = temp &#125; return arr&#125; 选择排序123456789101112131415161718func selectSort&lt;T: Comparable&gt; (oArr: [T]) -&gt; [T] &#123; var arr = oArr var minIndex = 0 // 记录每次遍历的最小值位置 for outerIndex in 0..&lt;arr.count &#123; minIndex = outerIndex for innerIndex in (outerIndex + 1)..&lt;arr.count &#123; if arr[minIndex] &gt; arr[innerIndex] &#123; minIndex = innerIndex // 判断最小值,记住下表 &#125; if minIndex != outerIndex &#123; let temp = arr[outerIndex] arr[outerIndex] = arr[minIndex] arr[minIndex] = temp &#125; &#125; &#125; return arr&#125; 更多的排序算法可以去百科看看]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift常用三方库]]></title>
      <url>%2F2016%2F10%2F25%2FSwift%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
      <content type="text"><![CDATA[开发应用最不缺的就是轮子,尤其是懒得写某个效果或者功能的时候都可以拿前人写好的三方库快速开发,总结一下新项目可能会用到的三方库 常用三方库网络请求 Alamofire : 小星星最多的网络请求库,支持iOS9以上版本,与AFNetworking同源SwiftHTTP : 又是一个好用的网络请求库,支持iOS8以上版本Just : 无意中发现的但是蛮好用的,支持iOS8以上版本 钥匙串 KeychainAccess : 用这东西记录用户名密码之类的挺方便的,用法也比较简单,支持iOS8以上版本 图片加载 Kingfisher : 图片加载中星星最高的库,支出iOS8.0以上版本 JSON解析 SwiftyJSON : JSON数据解析利器,不用手动层层解包了,支持iOS8以上版本 视图布局 SnapKit : 代码布局首选,与Masonry同源,支持iOS8以上版本 指示器 NVActivityIndicatorView : 一大堆样式可以选 本地存储 SQLite.swift : swift中星星最高的存储库,支持iOS7以上版本SwiftyUserDefaults : 在swift中用NSUserDefaults存储数据 控制台打印 XCGLogger : 花花绿绿五颜六色的打印结果最好看了,支持iOS8以上版本 相机相册图片 ImagePicker : 非常精致的一个图片选择器SKPhotoBrowser : 图片查看库 扩展类 EZSwiftExtensions : 整理的真心多 提示框 SweetAlert-iOS : 带动画的弹框,调用也简单,效果不错,支持iOS7以上版本SwiftMessages : 消息提示,到处都可以显示的横条,效果非常不错 内购 SwiftyStoreKit : 省心省时省力,内购封装 皮肤主题 SwiftTheme : 主题/换肤, 夜间模式,支持iOS7以上版本 二维码扫描 QRCodeReaderView-Swift : 基于swift语言实现二维码条形码扫描,本地相册二维码识别 指纹和手势密码 TouchIDAndGestureLock : 指纹解锁、手势解锁 通讯录 PPGetAddressBookSwift : 获取通讯录并排序 提示框 SweetAlert-iOS : 动画提示框]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cocoapods使用]]></title>
      <url>%2F2016%2F10%2F23%2Fcocoapods%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[最为iOS开发的一般都知道cocoapods,在管理三方库方面还是减少不少麻烦的,之前一直用的老版本的cocoapods,升级到1.0以上版本后,写法有所改变,再总结一下用法 创建项目CocoapodsDemo 用Xcode创建CocoapodsDemo项目,并设置支持的最低版本 添加Podfile文件cd到刚创建的项目的根目录下创建Podfile $ pod init 这时候查看项目文件夹会发现多出一个Podfile文件 打开该文件终端执行命令 $ vim Podfile或者$ open -e podfile 更推荐后者,vim编辑真心难用,需要一行一样的跳打开后我们会看到里面已经为我们创建了不少东西,省的自己写了 把碍眼的注释都删掉如果你在创建应用的时候勾选了Tests和UITest,则会同时创建出他们对应的target,我们暂时不用,也直接删了就行了,什么时候用到什么时候在加上这就顺眼多了 添加需要的三方库以添加Alamofire为例 首先查看Alamofire目前的版本,有三种 1.去github上看看文档介绍2.去Cocoapods官网上查查文档3.在终端上通过命令查询 $ pod search alamofire 前两者都能查到最新版本,第三种有可能查不到最新的,需要更新本地库 $ pod repo update 接下来按照查询到的方法在Podfile中书写 关闭编辑页面 拉取三方库资源 $ pod install 这时候打开项目文件,会发现多出了几个文件 打开.workspace文件即可看到多处了一Pods工程 以后要是需要更新三方库只需要执行命令 $ pod update 到这里cocoapods使用就结束了 接下来项目要是需要用到Pods里的三方库只需要引用头文件就能用了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cocoapods升级]]></title>
      <url>%2F2016%2F10%2F21%2Fcocoapods%E5%8D%87%E7%BA%A7%2F</url>
      <content type="text"><![CDATA[swift3.0许多库对cocoapods的版本也有要求,这使得我们不得不升级cocoapods,由于手边项目较多,一直没升级cocoapods,主要是懒得改,这次有时间了,就把它给升了吧. 切换gem源 $ gem sources –remove https://rubygems.org/$ gem source -a https://gems.ruby-china.org/ 查看是否切换成功 $ gem source -l 当现实为下图则为成功 升级cocoapods $ sudo gem install -n /usr/local/bin cocoapods或者试试下面的命令,这是更新推荐提示的命令$ sudo gem install cocoapods –pre 这时候会出现一大堆输出等结束 查看版本 $ pod –version 欧 买噶的,居然没有更新 不用紧张,可能是gem太老了,更新一下 $ gem update –system 估计得等一会,然后又输出一大堆东西等结束 再次执行 $ sudo gem install -n /usr/local/bin cocoapods$ pod –version 看到下面输出结果 ~~泪奔啊终于更新了 好了升级完成,接下来更新本地库,耐心等待即可 $ pod repo update 更新完之后可能会出现 CocoaPods 1.2.0.beta.1 is available. 这是发现还有新版本,不过是beta版本,要不要再升级,如果要就按照它提示的命令执行,否则就不用管它,beta一般就不升了,毕竟不是正式版,难免会有一些BUG]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[随机数]]></title>
      <url>%2F2016%2F10%2F19%2F%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
      <content type="text"><![CDATA[取10以内随机数arc4random() % 10 据说arc4random在32位iPhone上有时程序崩溃,用arc4random_uniform也行12let maxValue: UInt32 = 10print(Int(arc4random_uniform(maxValue))) 封装一下去随机数的方法1234func randomInRange(range: CountableClosedRange&lt;Int&gt;) -&gt; Int &#123; let count = UInt32(range.upperBound - range.lowerBound) return Int(arc4random_uniform(count)) + range.lowerBound&#125; 调用12取1到10之间的随机数randomInRange(range: (1...10)) 返回随机颜色12345678910extension UIColor &#123; open class var randomColor: UIColor&#123; get &#123; let red = CGFloat(arc4random()%256)/255.0 let green = CGFloat(arc4random()%256)/255.0 let blue = CGFloat(arc4random()%256)/255.0 return UIColor(red: red, green: green, blue: blue, alpha: 1.0) &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[本地化存储之SQLite.swift使用]]></title>
      <url>%2F2016%2F10%2F17%2F%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%AD%98%E5%82%A8%E4%B9%8BSQLite-swift%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[本地存储功能是APP常用功能,也是必备技能,OC时代,我们有很好用的FMDB三方库可以轻松实现本地化存储,Swift同样有不错的替代品,这里主要介绍的是SQLite.swift三方库,用起来也是很简单,这里以存储用户信息为例. 创建数据库文件1234567891011121314151617mutating func createdsqlite3() &#123; // 设置数据库路径 let sqlFilePath = NSHomeDirectory() + "/Documents/usersinfodb.sqlite3" do &#123; db = try Connection(sqlFilePath) try db.run(users.create(block: &#123; (table) in table.column(id, primaryKey: true) table.column(username) table.column(userage) table.column(usersex) table.column(userid) table.column(useremail) &#125;)) &#125; catch &#123; print("创建数据库出错: \(error)") &#125;&#125; 添加用户信息1234567891011121314151617181920212223242526func insertUser(userModel: DNUsersModel) &#123; // 用户信息中没有ID就不存入数据库(被列为无效用户) guard let userId = userModel.userid else &#123; print("没有ID信息,视为无效用户") return; &#125; // 查找数据库中是否有该用户,如果有则执行修改操作 guard readUser(userId: userId) == nil else &#123; print("已存在改用户,接下来更新此用户数据") updateUser(userId: userId, userModel: userModel) return &#125; let insert = users.insert(username &lt;- userModel.username, userage &lt;- userModel.userage, usersex &lt;- userModel.usersex, userid &lt;- userModel.userid, useremail &lt;- userModel.useremail) do &#123; let num = try db.run(insert) print(num) &#125; catch &#123; print("增加用户到数据库出错: \(error)") &#125;&#125; 删除指定用户信息123456789func deleteUser(userId: String) &#123; let currUser = users.filter(userid == userId) do &#123; let num = try db.run(currUser.delete()) print(num) &#125; catch &#123; print("删除用户信息出错: \(error)") &#125;&#125; 更新指定用户信息1234567891011121314func updateUser(userId: String, userModel: DNUsersModel) &#123; let currUser = users.filter(userid == userId) let update = currUser.update(username &lt;- userModel.username, userage &lt;- userModel.userage, usersex &lt;- userModel.usersex, userid &lt;- userModel.userid, useremail &lt;- userModel.useremail) do &#123; let num = try db.run(update) print(num) &#125; catch &#123; print(error) &#125;&#125; 更新用户名12345678910func updateUser(userId: String, userName: String) &#123; let currUser = users.filter(userid == userId) let update = currUser.update(username &lt;- userName) do &#123; let num = try db.run(update) print(num) &#125; catch &#123; print(error) &#125;&#125; 查询指定用户信息1234567891011121314func readUser(userId: String) -&gt; DNUsersModel? &#123; var userModel: DNUsersModel? = DNUsersModel() for user in try! db.prepare(users) &#123; if user[userid] == userId &#123; userModel?.username = user[username] userModel?.userage = user[userage] userModel?.usersex = user[usersex] userModel?.userid = user[userid] userModel?.useremail = user[useremail] return userModel &#125; &#125; return nil&#125; 查询所有用户信息12345678910111213func readAllUsers() -&gt; [DNUsersModel]? &#123; var usersArr: [DNUsersModel]? = [DNUsersModel]() var userModel: DNUsersModel? = DNUsersModel() for user in try! db.prepare(users) &#123; userModel?.username = user[username] userModel?.userage = user[userage] userModel?.usersex = user[usersex] userModel?.userid = user[userid] userModel?.useremail = user[useremail] usersArr?.append(userModel!) &#125; return usersArr&#125; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML速查表]]></title>
      <url>%2F2016%2F10%2F15%2FHTML%E9%80%9F%E6%9F%A5%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[HTML 是一种在 Web 上使用的通用标记语言。HTML 允许你格式化文本，添加图片，创建链接、输入表单、框架和表格等等，并可将之存为文本文件，浏览器即可读取和显示。 HTML 基本文档1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;文档标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 可见文本... &lt;/body&gt;&lt;/html&gt; 基本标签（Basic Tags）1234567891011&lt;h1&gt;最大的标题&lt;/h1&gt;&lt;h2&gt; . . . &lt;/h2&gt;&lt;h3&gt; . . . &lt;/h3&gt;&lt;h4&gt; . . . &lt;/h4&gt;&lt;h5&gt; . . . &lt;/h5&gt;&lt;h6&gt;最小的标题&lt;/h6&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;br&gt; （换行）&lt;hr&gt; （水平线）&lt;!-- 这是注释 --&gt; 文本格式化（Formatting）123456789101112131415161718&lt;b&gt;粗体文本&lt;/b&gt;&lt;code&gt;计算机代码&lt;/code&gt;&lt;em&gt;强调文本&lt;/em&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;kbd&gt;键盘输入&lt;/kbd&gt; &lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;small&gt;更小的文本&lt;/small&gt;&lt;strong&gt;重要的文本&lt;/strong&gt;&lt;abbr&gt; （缩写）&lt;address&gt; （联系信息）&lt;bdo&gt; （文字方向）&lt;blockquote&gt; （从另一个源引用的部分）&lt;cite&gt; （工作的名称）&lt;del&gt; （删除的文本）&lt;ins&gt; （插入的文本）&lt;sub&gt; （下标文本）&lt;sup&gt; （上标文本） 链接（Links）123456普通的链接： &lt;a href=" 链接文本&lt;/a&gt; 图像链接： &lt;a href="http://www.example.com/"&gt;&lt;img src="URL" alt="替换文本"&gt;&lt;/a&gt; 邮件链接： &lt;a href="mailto:webmaster@example.com"&gt;发送e-mail&lt;/a&gt;书签： &lt;a id="tips"&gt;提示部分&lt;/a&gt; &lt;a href="#tips"&gt;跳到提示部分&lt;/a&gt; 图片（Images）1&lt;img src="URL" alt="替换文本" height="42" width="42"&gt; 样式/区块（Styles/Sections）12345678&lt;style type="text/css"&gt; h1 &#123;color:red;&#125; p &#123;color:blue;&#125;&lt;/style&gt;&lt;div&gt;文档中的块级元素&lt;/div&gt;&lt;span&gt;文档中的内联元素&lt;/span&gt; 无序列表1234&lt;ul&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt;&lt;/ul&gt; 有序列表1234&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt; 自定义列表123456&lt;dl&gt; &lt;dt&gt;项目 1&lt;/dt&gt; &lt;dd&gt;描述项目 1&lt;/dd&gt; &lt;dt&gt;项目 2&lt;/dt&gt; &lt;dd&gt;描述项目 2&lt;/dd&gt;&lt;/dl&gt; 表格（Tables）12345678910&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 框架（Iframe）1&lt;iframe src="demo_iframe.htm"&gt;&lt;/iframe&gt; 表单（Forms）12345678910111213141516171819&lt;form action="demo_form.php" method="post/get"&gt;&lt;input type="text" name="email" size="40" maxlength="50"&gt; &lt;input type="password"&gt; &lt;input type="checkbox" checked="checked"&gt; &lt;input type="radio" checked="checked"&gt; &lt;input type="submit" value="Send"&gt; &lt;input type="reset"&gt; &lt;input type="hidden"&gt; &lt;select&gt; &lt;option&gt;苹果&lt;/option&gt; &lt;option selected="selected"&gt;香蕉&lt;/option&gt; &lt;option&gt;樱桃&lt;/option&gt; &lt;/select&gt;&lt;textarea name="comment" rows="60" cols="20"&gt;&lt;/textarea&gt; &lt;/form&gt; 实体（Entities）123&amp;lt; 等同于 &lt;&amp;gt; 等同于 &gt;© 等同于 ©]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode8去除多余打印]]></title>
      <url>%2F2016%2F10%2F13%2FXcode8%E5%8E%BB%E9%99%A4%E5%A4%9A%E4%BD%99%E6%89%93%E5%8D%B0%2F</url>
      <content type="text"><![CDATA[打开路径 Product -&gt; Scheme -&gt; Edit Scheme 配置内容 OS_ACTIVITY_MODE=disable]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode8 权限配置]]></title>
      <url>%2F2016%2F10%2F11%2FXcode8-%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[iOS10之后加强了权限管理,在使用某项系统权限的时候需要在plist中配置,如果不配置,在上传项目之后构建版本在itunes connect里可能看不到,审核也可能被拒 相机权限 Privacy - Camera Usage Description 是否允许此App使用你的相机 相册权限 Privacy - Photo Library Usage Description 是否允许此App访问你的媒体资料库 定位权限 Privacy - Location When In Use Usage Description 我们需要通过您的地理位置信息获取您周边的相关数据 Privacy - Location Always Usage Description 我们需要通过您的地理位置信息获取您周边的相关数据 通讯录权限 Privacy - Contacts Usage Description 是否允许此App访问你的通讯录 麦克风权限 Privacy - Microphone Usage Description 是否允许此App使用你的麦克风 蓝牙权限 Privacy - Bluetooth Peripheral Usage Description 是否许允此App使用蓝牙 语音转文字权限 Privacy - Speech Recognition Usage Description 是否允许此App使用语音识别 日历权限 Privacy - Calendars Usage Description 是否允许此App使用日历]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[地理定位]]></title>
      <url>%2F2016%2F10%2F09%2F%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%2F</url>
      <content type="text"><![CDATA[现在的app基本上都有定位功能,又得是获取左边和城市信息,又得是地图展示,这里介绍获取简单的地理位置信息功能,包括坐标,所在城市等基本信息. 添加依赖库 导入头文件12345678CoreLocation.frameworkimport CoreLocation// 别忘了在plist中添加隐私权限Privacy - Location Always Usage DescriptionPrivacy - Location When In Use Usage Description都是String类型 后面描述: 我们需要通过您的地理位置信息获取您周边的相关数据 初始化相关对象123456789101112131415// 创建一个CLLocationManager对象private var locationManager: CLLocationManager!// 创建一个CLGeocoder对象private var geocoder: CLGeocoder!// 初始化locationManagerlocationManager = CLLocationManager()locationManager.delegate = selflocationManager.desiredAccuracy = kCLLocationAccuracyBest //定位精准度locationManager.distanceFilter = 100 // 超出范围更新位置信息if Double(UIDevice.current.systemVersion)! &gt;= 8.0 &#123; locationManager.requestWhenInUseAuthorization() // 使用期间&#125;// 初始化geocodergeocoder = CLGeocoder() 开始定位1locationManager.startUpdatingLocation() 添加代理并实现代理方法123456789101112131415161718192021222324252627282930313233343536373839CLLocationManagerDelegatefunc locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) &#123; print("每当请求到位置信息时都会调用此方法") if let location = locations.first &#123; // 坐标 print(location) geocoder.reverseGeocodeLocation(location) &#123; (placemarks, error) in if let placemark = placemarks?.first &#123; print(placemark.locality) &#125; &#125; &#125; &#125; // 不需要定位的时候停止定位 manager.stopUpdatingLocation()&#125;func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) &#123; print("定位失败: %@", error)&#125;func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) &#123; switch status &#123; case .notDetermined: print("用户未决定") case .restricted: // 暂时没啥用 print("访问受限") case .denied: // /定位关闭时和对此APP授权为never时调用 if CLLocationManager.locationServicesEnabled() &#123; print("定位开启,但被拒绝") &#125; else &#123; print("定位关闭,不可用") &#125; case .authorizedAlways: print("获取前后台定位授权") case .authorizedWhenInUse: print("获取前台定位授权") &#125;&#125; 为了提高用户体验,通常当检测到用户为打开定位功能的时候让用户便捷跳转到设置界面123456789101112131415161718192021222324if let settingUrl = URL(string: UIApplicationOpenSettingsURLString) &#123; if UIApplication.shared.canOpenURL(settingUrl) &amp;&amp; Double(UIDevice.current.systemVersion)! &gt;= 8.0 &#123; //iOS8可直接跳转到设置界面 let alertVC = UIAlertController(title: "提示", message: "定位功能被拒绝，是否前往设置开启", preferredStyle: .alert) let cancelAction = UIAlertAction(title: "取消", style: .cancel, handler: &#123; (action) in &#125;) let okAction = UIAlertAction(title: "确定", style: .default, handler: &#123; (action) in UIApplication.shared.openURL(settingUrl) &#125;) alertVC.addAction(cancelAction) alertVC.addAction(okAction) let vc = UIApplication.shared.keyWindow?.rootViewController vc?.present(alertVC, animated: true, completion: nil) &#125; else &#123; let alertVC = UIAlertController(title: "提示", message: "定位服务未开启\n打开方式:设置-&gt;隐私-&gt;定位服务", preferredStyle: .alert) let cancelAction = UIAlertAction(title: "确定", style: .cancel, handler: &#123; (action) in &#125;) alertVC.addAction(cancelAction) let vc = UIApplication.shared.keyWindow?.rootViewController vc?.present(alertVC, animated: true, completion: nil) &#125;&#125; 下载源码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[系统声音服务的使用]]></title>
      <url>%2F2016%2F10%2F07%2F%E7%B3%BB%E7%BB%9F%E5%A3%B0%E9%9F%B3%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[系统声音服务(System Sound Services)提供了一个接口，用于播放不超过30秒的声音。它支持的文件格式有限，具体地说只有CAF、AIF和使用PCM或IMA/ADPCM数据的WAV文件。由于这些函数没有提供操纵声音和控制音量的功能，所以当你为多媒体或者游戏创建专门的配乐时，不要使用系统声音服务。 系统声音服务的使用(播放声音,提醒,震动)系统声音服务要求 1.系统声音播放不能超过30s2.允许格式: CAF AIF 和使用PCM IMA/ADPCM数据的WAV文件 支持三种类型 1.声音: 立即播放一个简单声音,手机静音则什么声音都没有2.提醒: 播放一个声音文件如果手机设为静音或震动，则通过震动提醒用户3.震动: 震动手机，而不考虑其他设置 注意事项: 导入音频文件之后,有时候会出现Bundle.main.path(forResource: sound, ofType: type) 这个方法获取不到资源的问题原因: xcode没有自动将文件添加到你的资源文件中解决: build Phases中的 copy Bundle Resources中点击”+”手动添加资源文件 使用方法导入头文件1import AudioToolbox 声音播放1234567891011func playAlertSound(sound: String, type: String) &#123; // 建立sysytemSoundID对象 var soundID: SystemSoundID = 0 // 获取声音地址 guard let soundPath = Bundle.main.path(forResource: sound, ofType: type) else &#123; return &#125; guard let soundUrl = NSURL(string: soundPath) else &#123; return &#125; // 赋值 AudioServicesCreateSystemSoundID(soundUrl, &amp;soundID) // 播放声音 AudioServicesPlaySystemSound(soundID)&#125; 提醒1234567891011func playSystemAlert(sound: String, type: String) &#123; // 建立sysytemSoundID对象 var soundID: SystemSoundID = 0 // 获取声音地址 guard let soundPath = Bundle.main.path(forResource: sound, ofType: type) else &#123; return &#125; guard let soundUrl = NSURL(string: soundPath) else &#123; return &#125; // 赋值 AudioServicesCreateSystemSoundID(soundUrl, &amp;soundID) // 提醒（同播放声音唯一的一个区别） AudioServicesPlayAlertSound(soundID)&#125; 震动1234// 建立的SystemSoundID对象let soundID = SystemSoundID(kSystemSoundID_Vibrate)// 振动AudioServicesPlaySystemSound(soundID) 防止出现重复点击声音覆盖 通常我们会在上一个声音播放完成之后才会调用下一次播放这里就会用到完成的回调方法 AudioServicesAddSystemSoundCompletion 例:123456789101112131415161718192021222324func playAlertSound(sound: String, type: String) &#123; if !isPlaying &#123; isPlaying = true // 建立sysytemSoundID对象 var soundID: SystemSoundID = 0 // 获取声音地址 guard let soundPath = Bundle.main.path(forResource: sound, ofType: type) else &#123; return &#125; guard let soundUrl = NSURL(string: soundPath) else &#123; return &#125; // 赋值 AudioServicesCreateSystemSoundID(soundUrl, &amp;soundID) // 播放声音 AudioServicesPlaySystemSound(soundID) // 播放完成回调 let pointer = Unmanaged.passUnretained(self).toOpaque() AudioServicesAddSystemSoundCompletion(soundID, nil, nil, &#123; (soundID, pointer) in print("播放完成") let mySelf = Unmanaged&lt;ViewController&gt;.fromOpaque(pointer!).takeUnretainedValue() mySelf.isPlaying = false AudioServicesRemoveSystemSoundCompletion(soundID) AudioServicesDisposeSystemSoundID(soundID) &#125;, pointer) &#125;&#125; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[指纹解锁]]></title>
      <url>%2F2016%2F10%2F05%2F%E6%8C%87%E7%BA%B9%E8%A7%A3%E9%94%81%2F</url>
      <content type="text"><![CDATA[指纹识别是从iPhone 5s开始支持的,在日常使用中,可以用来解锁手机和软件内部验证等用途,这里介绍的是在软件内部的使用,现在市面上应用的指纹解锁的应用还是很多的,尤其以金钱交易类的应用作为快捷登录和支付来使用,例如支付宝,招商银行等. 这里具体讲解一下如何使用指纹识别技术解锁应用 添加依赖库 引用头文件1234LocalAuthentication.frameworkimport LocalAuthentication 实现指纹识别方法1234567891011121314151617181920212223242526func LocalAuthenticationLogin() &#123; // 本地认证上下文联系对象 let context = LAContext() var error: NSError? // 判断设备是否具备指纹认证功能 if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &amp;error) &#123; print("可以指纹识别了") context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: "验证指纹以确认您的身份", reply: &#123; (success, error) in if success &#123; print("指纹验证成功") DispatchQueue.main.async &#123; //更新UI 必须在主线程中更新,否则天知道要到猴年马月能执行 &#125; &#125; else &#123; print("指纹验证失败 错误原因:\(error)") let errorMessage = self.errorMessageForError(aerror: error) print(errorMessage) &#125; &#125;) &#125; else &#123; let errorMessage = self.errorMessageForError(aerror: error) print(errorMessage) &#125;&#125; 归纳验证错误原因123456789101112131415161718192021222324252627282930313233func errorMessageForError(aerror: Error?) -&gt; String &#123; var errorMessage = "" if let error = aerror as? NSError &#123; switch error.code &#123; case LAError.authenticationFailed.rawValue: errorMessage = "身份验证不成功" case LAError.userCancel.rawValue: errorMessage = "手动取消验证" case LAError.userFallback.rawValue: errorMessage = "使用密码登录" case LAError.systemCancel.rawValue: errorMessage = "身份验证被系统取消" case LAError.passcodeNotSet.rawValue: errorMessage = "没有设置密码" case LAError.touchIDNotAvailable.rawValue: errorMessage = "设备不支持指纹" case LAError.touchIDNotEnrolled.rawValue: errorMessage = "没有登记的手指触摸ID" default: errorMessage = "" &#125; if #available(iOS 9.0, *)&#123; if error.code == LAError.touchIDLockout.rawValue &#123; errorMessage = "TouchID被锁" &#125; else if error.code == LAError.appCancel.rawValue &#123; errorMessage = "认证被取消应用程序" &#125; else if error.code == LAError.invalidContext.rawValue &#123; errorMessage = "调用之前已经失效" &#125; &#125; &#125; return errorMessage&#125; 当TouchID被锁 5次验证失败之后TouchID会被锁死,无法再调起指纹识别,这时候我们需要调起系统密码输入界面输入密码来重现验证指纹功能 123456789101112131415@available(iOS 9.0, *)func alertSystemPasswordView() &#123; // 本地认证上下文联系对象 let context = LAContext() var error: NSError? if context.canEvaluatePolicy(.deviceOwnerAuthentication, error: &amp;error) &#123; context.evaluatePolicy(.deviceOwnerAuthentication, localizedReason: "通过Home键验证已有手机指纹", reply: &#123; (success, error) in if success &#123; print("重设成功") &#125; else &#123; print("重设失败") &#125; &#125;) &#125;&#125; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[内购退款流程]]></title>
      <url>%2F2016%2F10%2F03%2F%E5%86%85%E8%B4%AD%E9%80%80%E6%AC%BE%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[苹果提供购买后返回的流程,一般不管什么原因,90天内一般都能退款,下面介绍一下具体退款流程 1.打开itunes 手机连接电脑,打开itunes软件,在三个点中选择应用的选项 2.打开账号记录 3.选择购买历史记录 4.选择问题报告可查看订单号或者退款 APP内购因为存在退款问题,而苹果没有实时的退款通知,也导致了很多刷单的情况,比如游戏中购买道具,通过充值-退款的反复操作刷道具,这也是做苹果内购最头疼的时,不过对于消费者来说还是不要随便刷单,一经发现有故意退款的情况,以后就很难再通过退款,这属于个人信用问题,不过,如果是正常的退款则没有影响]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo建站]]></title>
      <url>%2F2016%2F10%2F01%2Fhexo%E5%BB%BA%E7%AB%99%2F</url>
      <content type="text"><![CDATA[hexo可以方便的建立个人博客,托管在github上免费建立个人博客 准备工作配置环境 Node.js Git 安装后的显示 安装hexo1$ npm install -g hexo-cli 给我们的Blog创建一个文件夹 1$ hexo init 继续执行 12$ hexo g$ hexo s --debug 执行完后,在浏览器中打开 http://localhost:4000/显示默认主题 安装主题以NexT主题为例下载 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用 NexT 主题 更新主题12cd themes/next$ git pull origin master 打开站点配置文件_config.yml,找到theme,将landscape替换成next 执行 12$ hexo clean$ hexo s --debug 可以看到如下界面 要部署到github上的时候执行 123$ hexo clean$ hexo g$ hexo d 有时候会出现错误 ERROR Deployer not found: git 这时候我们需要执行 1$ npm install hexo-deployer-git --save 然后在重新执行部署到github的操作 更多样式配置可查看 这里]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[定律,定理,定则,公理,原理区别]]></title>
      <url>%2F2016%2F10%2F01%2F%E5%AE%9A%E5%BE%8B-%E5%AE%9A%E7%90%86-%E5%AE%9A%E5%88%99-%E5%85%AC%E7%90%86-%E5%8E%9F%E7%90%86%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[定律 定律是为实践和事实所证明，反映事物在一定条件下发展变化的客观规律的论断。例如牛顿运动定律、能量守恒定律、欧姆定律等。定律是一种理论模型，它用以描述特定情况、特定尺度下的现实世界，在其它尺度下可能会失效或者不准确。没有任何一种理论可以描述宇宙当中的所有情况，也没有任何一种理论可能完全正确。 定理 已经证明具有正确性、可以作为原则或规律的命题或公式，如几何定理。定理是从真命题（公理或其他已被证明的定理）出发，经过受逻辑限制的演绎推导，证明为正确的结论，即另一个真命题。例如“平行四边形的对边相等”就是平面几何中的一个定理。一般来说，在数学中，只有重要或有趣的陈述才叫定理。证明定理是数学的中心活动。相信为真但未被证明的数学叙述为猜想，当它被证明为真后便是定理。它是定理的来源，但并非唯一来源。一个从其他定理引伸出来的数学叙述，可以不经过证明成为猜想的过程，成为定理。定理已经证明具有正确性、可作为原则或规律的命题或公式。例如：“平行四边形对边相等”就是儿何学中的一个定理。 定则 公认的一种用以表达事物间内在联系的力一法，其目的是帮助理解及记忆。最常见的如右手定则，左手定则，安培螺旋法则等。 公理 经过人类长期反复的实践检验是真实的，不需要由其他判断加以证明的命题和原理。即目前大家都认可的，一定成立的命题。如传统形式逻辑三段论关于一类事物的全部是什么或不是什么，那么这类事物中的部分也是什么或不是什么，也即如果对一类事物的全部有所断定，那么对它的部分也就有所断定，便是公理。又如日常生活中人们所使用的“有生必有死”，”平面内过两点的直线有且只有一条。”也属于这种不证自明的判断。 原理 自然科学和社会科学中具有普遍意义的基本规律。是在大量观察、实践的基础上，经过归纳、概括而得出的。既能指导实践，又必须经受实践的检验。换句话说，指文字原来的理由,最基础,最根本的理论，或指某一领域或学科中带有普遍性的、最基本的、可以作为其他规律的基础的规律。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F10%2F01%2FHello-World%2F</url>
      <content type="text"><![CDATA[最近闲的蛋疼,开个博客玩玩. 这个博客是干什么的 其实主要是记录一下在开发过程中总结一些经验,和遇到的一些问题,到时候回头忘掉了还可以在翻翻看,同时也督促自己每天梳理一下知识点,省的闲的没事干什么都忘了,这里有自己的总结,也有看到别人写的好的代码总结,反正就是总结 为什么开通这个博客 好多分享平台都不错,之前在CSDN,简书等都开过博客,我为什么还要再费时费力的自己搭建博客呢,就一个原因,我想起的名字各个平台基本上都被占用的,在这里,我爱起什么名字就起什么名字,就是这么任性. 怎么对待这个博客 争取每天都能分享一点,只要有意义的都可以,日积月累就会有更多的内容值得自己去回味反思. 注意 本博客是搭建在GitHub上的,域名也是原始域名,没有钱买域名了😭, 就这样吧,有些内容里面的链接什么的可能需要科学上网才能访问,这个相信生活在天朝的人们都会的]]></content>
    </entry>

    
  
  
</search>
