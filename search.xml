<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[webview快速滚动]]></title>
      <url>%2F2017%2F05%2F04%2Fwebview%E5%BF%AB%E9%80%9F%E6%BB%9A%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[浏览器默认滚动速度相对于原生来说比较慢,通过webview的scroller代理来实现网页的快速滑动 设置webview的scrollerview代理 1webView.scrollView.delegate = self; 遵守代理123- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView &#123; scrollView.decelerationRate = UIScrollViewDecelerationRateNormal;&#125; 实现上面代码即可使得webview页面快速滑动]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode快捷键总结]]></title>
      <url>%2F2017%2F04%2F26%2FXcode%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[日常开发中用到的一些快捷键操作总结,让你写的飞起,告别鼠标 快速操作代码代码移动1234上：command + option + [下：command + option + ]左：command + [右：command + ] 光标移动移动到整个编辑区域12顶部: command + ⬆️底部: command + ⬇️ 移动到所在行12最前面: command + ⬅️最后面: command + ➡️ 移动到所在单词12最前面: option + ⬅️最后面: option + ➡️ 移动到某一行1command + L 返回上次光标所在位置12control + command + ⬅️control + command + ➡️ 文本选取自定义文本选取1shift + ⬆️ ⬇️ ⬅️ ➡️ 选取最近单词1option + shift +⬅️ ➡️ 选取当前行1command + shift + ⬅️ ➡️ 鼠标功能替代12345678910111213control + B: 向左一个字符（backward）control + F: 向右一个字符（forward）control + P: 前一行（previous）control + N: 后一行（next）control + A: 行首control + E: 行尾control + L : 将光标所在地置于窗口正中control + T: 调换光标两边的字符control + D: 删除光标右侧的一个字符control + K: 删除光标右侧的所有字符command + delete 删除光标左侧的所有字符option + delete 删除光标之前的一个单词（以空格隔开就算一个单词）control + delete 删除光标之前的一个单词 (驼峰命名法中，每个部分作为一个单词) 代码操作代码块隐藏/显示1command + option + ⬅️ ➡️ 全局替换变量1command + control + e 添加/取消注释1command + / 添加整段注释1command + option + / Xcode窗口双窗口编辑器12开: command + option + enter关: command + enter 搜索与替换123456789101112全局搜索:Command + Shift + F ： 快速打开左侧搜索导航器（搜索模式）Command + Shift + Option + F ：快速打开左侧搜索导航器（替换模式）Command + 3 ：同上两个文档内搜索:Command + F: 搜索command + E : 使用当前选中内容查找Command + G: 搜索下一处Shift + Command + G: 搜索上一处 Xcode中页面跳转123456789101112Xcode中页面跳转Command + control + F ： Xcode 全屏Command + Shift + 0 (Zero) ： 显示苹果官方文档页面在类或者方法名上执行Option + Left-click操作 ：快速帮助control + 6 ：弹出当前class方法列表control + 1 ：查看方法的调用者control + 2 、3、4.... ：上方菜单栏对应的页面command + shift + y：隐藏/打开控制台:command + control + ⬆️/⬇️ 快速切换到.m文件/.h文件:command + shift + J ： 快速定位到当前编辑文件的导航区域（左侧的文件目录）command + shift + O ：快速打开某一个文件（快捷搜索、打开文件）command + , ：打开偏好设置 运行与调试编译与运行12345Command + R 运行。Command + . 停止Command + B: 编译Command + SHIFT + B 分析代码，找到潜在内存溢出问题Command + SHIFT + K: 清理 调试模式12345678910111213Command + shift + Y ：调试区视图打开/关闭Command + K ： 清理 控制台Command + shift + C ：打开控制台窗口Command + \ ： 当前行设置/取消断点Command + Y 全局激活或禁用断点F6 调试时 Step OverF7 调试时 Step IntoF8 调试时 Step OutControl + Command + Y : debug断点时continueCommand + Alt + P ： 继续（在调试中）Command + Alt + 0 ：跳过Command + Alt + I ：跳入 xcode shem管理Command + Alt + T ：跳出 文件相关12345678910新建项目 Command +shift+ N新建文件 Command + N新建空文件 Command +control+ N打开 Command + O关闭窗口 Command +W保存: Command + S保存所有文件 Command +option+S另存为 : Command + SHIFT + SCommand + Alt + 上方向键 ：打开配套文件Command + D ：添加书签]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[水波纹效果]]></title>
      <url>%2F2017%2F03%2F03%2FwaveView%2F</url>
      <content type="text"><![CDATA[水波效果实现该效果主要是运用sin函数的效果 12345678910111213141516171819202122// 开始波动 @discardableResult public func wave() -&gt; Bool &#123; // 如果正在波动就不重复执行 if waveShapeLayer?.path != nil &#123; return false &#125; // 创建波纹 waveShapeLayer = CAShapeLayer() waveShapeLayer?.fillColor = waveColor?.cgColor layer.addSublayer(waveShapeLayer!) waveDisplayLink = CADisplayLink(target: self, selector: #selector(currentWave)) waveDisplayLink?.add(to: RunLoop.main, forMode: .commonModes) // 一定时间后自动停止波动 if Double(waveTime!) &gt; 0.0 &#123; DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + Double(waveTime!), execute: &#123; self.stop() &#125;) &#125; return true &#125; 1234567891011// 停止波动 func stop() &#123; UIView.animate(withDuration: 1.0, animations: &#123; self.alpha = 0 &#125;) &#123; (finished) in self.waveDisplayLink?.invalidate() self.waveDisplayLink = nil self.waveShapeLayer?.path = nil self.alpha = 1 &#125; &#125; 123456789101112131415161718func currentWave() &#123; self.offsetX = (self.offsetX ?? 0.0) - (self.waveSpeed ?? 0.0) * (self.superview?.frame.size.width)! / CGFloat(self.frame.size.width) let width: CGFloat = self.frame.width let height: CGFloat = self.frame.height let path: CGMutablePath = CGMutablePath() //设置移动到某点 path.move(to: CGPoint(x: CGFloat(0), y: CGFloat(height / 2)), transform: .identity) var y: CGFloat = 0 for x in 0...Int(width) &#123; y = height * sin(0.01 * (self.angularSpeed! * CGFloat(x) + self.offsetX!)) path.addLine(to: CGPoint(x: CGFloat(x), y: y), transform: .identity) &#125; path.addLine(to: CGPoint(x: width, y: height), transform: .identity) path.addLine(to: CGPoint(x: CGFloat(0), y: height), transform: .identity) //闭合路径 path.closeSubpath() self.waveShapeLayer?.path = path &#125; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[三方支付]]></title>
      <url>%2F2017%2F03%2F02%2F%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98%2F</url>
      <content type="text"><![CDATA[最近项目需要集成第三方支付,主要是以微信和支付宝为主,顺手就封装了一下,方便以后的使用 支付宝集成订单信息由服务端生成,返回一个字符串orderString 123456789- (void)aliPayWithOrderString:(NSString *)orderString &#123; if (orderString.length &gt; 0) &#123; //应用注册scheme,在AliSDKDemo-Info.plist定义URL types NSString *appScheme = @"alisdkdemo"; [[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic) &#123; NSLog(@"alipay result: %@", resultDic); &#125;]; &#125;&#125; 微信集成注册1[WXApi registerApp:weixinAppID]; 服务端返回订单信息 123456789101112131415161718192021- (void)weChatPayWithDict:(NSDictionary *)dict &#123; if(dict != nil)&#123; NSMutableString *retcode = [dict objectForKey:@"retcode"]; if (retcode.intValue == 0)&#123; NSMutableString *stamp = [dict objectForKey:@"timestamp"]; //调起微信支付 PayReq* req = [[PayReq alloc] init]; req.partnerId = [dict objectForKey:@"partnerid"]; req.prepayId = [dict objectForKey:@"prepayid"]; req.nonceStr = [dict objectForKey:@"noncestr"]; req.timeStamp = stamp.intValue; req.package = [dict objectForKey:@"package"]; req.sign = [dict objectForKey:@"sign"]; [WXApi sendReq:req]; //日志输出 NSLog(@"appid=%@\npartid=%@\nprepayid=%@\nnoncestr=%@\ntimestamp=%ld\npackage=%@\nsign=%@",[dict objectForKey:@"appid"],req.partnerId,req.prepayId,req.nonceStr,(long)req.timeStamp,req.package,req.sign ); &#125;else&#123; NSLog(@"服务器返回错误，未获取到json对象"); &#125; &#125;&#125; 遵守代理WXApiDelegate 12- (void)onResp:(BaseResp*)resp ;- (void)onReq:(BaseReq*)req; ##三方登陆回调 12345678910111213141516- (void)openURL:(NSURL *)url &#123; // 支付宝回调 if ([url.host isEqualToString:@"safepay"]) &#123; // 支付跳转支付宝钱包进行支付，处理支付结果 [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123; NSLog(@"result = %@",resultDic); &#125;]; return; &#125; // 微信回调 if ([url.host isEqualToString:@"pay"]) &#123; [WXApi handleOpenURL:url delegate:self]; return; &#125; &#125; 在AppDelegate中调用 1234567891011// iOS9前- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; [[DNPayManager sharedInstance] openURL:url]; return YES;&#125;// iOS9后- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options&#123; [[DNPayManager sharedInstance] openURL:url]; return YES;&#125; 遇到的问题支付宝在封装的时候出现SDK中爆红Unknown type name &#39;UIWindow&#39;,解决方法由于是在NSObject类中封装,缺少UI框架,只需要在封装类中添加#import &lt;UIKit/UIKit.h&gt;即可 微信在调用[WXApi registerApp:weixinAppID];时崩溃,显示如下问题1-[__NSArrayM enqueue:]: unrecognized selector sent to instance 0x174056620 解决方法:在other linker flags中添加-ObjC即可 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Big-O Notation了解]]></title>
      <url>%2F2017%2F03%2F01%2FBig-O-Notation%E4%BA%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[Big-O表示法给你一个算法的运行时间和它使用的内存量的粗略指示 什么是大O符号 大O符号(Big-O notation)是用于描述函数渐近行为的数学符号在计算科学中,它在分析算法复杂性方面非常有用 解决一个规模为n的问题所花费的时间可表示为: $ T(n)=4n^{2}-2n+2 $, 当n足够大的时候$n^2$将会占据主导地位,此时可用大O符号表示:$T(n) = O(n^2)$,这时我们可以称该算法具有$n^2$阶的时间复杂度 常用的函数阶数 大O 名称 描述 $O(1)$ 常数 无论多少数据,改算法总是花费相同的时间.例如:通过索引查找数组的元素。 $O(logn)$ 对数 每次迭代将数据量减半.例如:二进制搜索 $O(n)$ 线性 数据加倍算法时间也加倍.例如:顺序搜索 $O(nlogn)$ 线性对数 例如:快速排序 $O(n^2)$ 平方 例如:使用嵌套循环算法的插入排序 $O(2^n)$ 指数 慢的要命 $O(n!)$ 阶乘 无法接受的慢 注:大O表示法只是一个估值,只有在n足够大的时候才有用,算法要根据实际问题选取]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIPopoverPresentationController使用]]></title>
      <url>%2F2017%2F02%2F23%2FUIPopoverPresentationController%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[UIPopoverPresentationController在iOS8之后可以放心大胆的用了 代码实现1234567891011121314151617181920212223242526272829303132333435363738extension ViewController: UIPopoverPresentationControllerDelegate &#123; func popView(_ isitemBar: Bool, customView: UIView) &#123; let view = DNPopViewController() // popover视图的大小 view.preferredContentSize = CGSize(width: CGFloat(300), height: CGFloat(200)) // 样式 view.modalPresentationStyle = .popover // 如果没有这句，pop不会被初始化 let pop: UIPopoverPresentationController? = view.popoverPresentationController // 背景色 pop?.backgroundColor = UIColor.red // 设置代理 pop?.delegate = self // 弹出的方向 pop?.permittedArrowDirections = .up if !isitemBar &#123; // 设置要弹出视图的参照View pop?.sourceView = customView; // 弹出位置偏移 pop?.sourceRect = CGRect(x: customView.frame.size.width / 2, y: 30, width: 0, height: 0) &#125; else &#123; // itemBar上显示 pop?.barButtonItem = navigationItem.leftBarButtonItem &#125; //导航栏右侧的按钮 self.present(view, animated: true, completion: &#123; _ in &#125;) //present即可 &#125; // 没有设置这个出现一个大黑屏 func adaptivePresentationStyle(for controller: UIPresentationController) -&gt; UIModalPresentationStyle &#123; return .none &#125; &#125; 效果图 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[alamofire cookies 存取]]></title>
      <url>%2F2017%2F02%2F23%2Falamofire-cookies-%E5%AD%98%E5%8F%96%2F</url>
      <content type="text"><![CDATA[我们在用alamofire请求数据的时候,alamofire会在请求中携带cookie,不过应用重启之后,cookies就不知道跑哪去了,这是后我们需要对cookies进行保存,以便下次打开应用的时候能够携带. 获取cookies123456789Alamofire.request("https://httpbin.org/get").responseData &#123; (response) in let headerFields = response.response?.allHeaderFields as! [String: String] let url = response.request?.url let cookies = HTTPCookie.cookies(withResponseHeaderFields: headerFields, for: url!) var cookieArray = [ [HTTPCookiePropertyKey : Any ] ]() for cookie in cookies &#123; cookieArray.append(cookie.properties!) &#125; &#125; 保存cookies1UserDefaults.standard.set(cookieArray, forKey: "alamofire_cookies") 读取并重新设置cookies 这一步一般在appdelegate中设置即可 12345678910if let cookieArray = UserDefaults.standard.array(forKey: "alamofire_cookies") &#123; for cookieData in cookieArray &#123; if let dict = cookieData as? [HTTPCookiePropertyKey : Any] &#123; if let cookie = HTTPCookie.init(properties : dict) &#123; HTTPCookieStorage.shared.setCookie(cookie) print("cookie: \(cookie)") &#125; &#125; &#125; &#125; 读取到的cookies样式 123456789101112&#123; &quot;args&quot;: &#123;&#125;, &quot;headers&quot;: &#123; &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip;q=1.0, compress;q=0.5&quot;, &quot;Accept-Language&quot;: &quot;zh-Hans-US;q=1.0, en;q=0.9&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;DNSwiftProject/1.0 (com.wjn.DNJPushDemo; build:1; iOS 10.2.0) Alamofire/4.2.0&quot; &#125;, &quot;origin&quot;: &quot;119.40.36.206&quot;, &quot;url&quot;: &quot;https://httpbin.org/get&quot;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HealthKit--步数修改]]></title>
      <url>%2F2017%2F02%2F21%2FHealthKit--%E6%AD%A5%E6%95%B0%E4%BF%AE%E6%94%B9%2F</url>
      <content type="text"><![CDATA[微信,QQ中都有运动数据展示,在好友中的排名等,这里所提供的是通过修改健康中心的数据来达到刷数据的效果,让你成为数据中的运动达人,不过只是娱乐而已,而且微信只有第一次运行才会成功,其他时候都是读取手机本身的数据,而不对第三方修改的数据进行统计,QQ就没这个问题啦,当然数据修改不要超过100000步,太多了QQ也不认识了 获取健康中心的读写权限12345678910111213141516171819// 设置请求的权限,这里我们只获取读取和写入步数let stepType: HKQuantityType? = HKObjectType.quantityType(forIdentifier: .stepCount)let dataTypesToRead = NSSet(objects: stepType as Any)// 权限请求self.healthStore?.requestAuthorization(toShare: dataTypesToRead as? Set&lt;HKSampleType&gt;, read: dataTypesToRead as? Set&lt;HKObjectType&gt;, completion: &#123; [unowned self] (success, error) in // 得到权限后就可以获取步数和写入了 if success &#123; self.fetchSumOfSamplesToday(for: stepType!, unit: HKUnit.count()) &#123; (stepCount, error) in // 获取到步数后,在主线程中更新数字 DispatchQueue.main.async &#123; self.stepsNumberLabel.text = "\(stepCount!)" &#125; &#125;&#125; else &#123; let alert = UIAlertController(title: "提示", message: "不给权限我还怎么给你瞎写步数呢,可以去设置界面打开权限", defaultActionButtonTitle: "确定", tintColor: UIColor.red) alert.show() &#125;&#125;) 读取步数1234567891011121314151617181920212223func fetchSumOfSamplesToday(for quantityType: HKQuantityType, unit: HKUnit, completion completionHandler: @escaping (Double?, NSError?)-&gt;()) &#123; let predicate: NSPredicate? = self.predicateForSamplesToday() let query = HKStatisticsQuery(quantityType: quantityType, quantitySamplePredicate: predicate, options: .cumulativeSum) &#123; query, result, error in var totalCalories = 0.0 if let quantity = result?.sumQuantity() &#123; let unit = HKUnit.count() totalCalories = quantity.doubleValue(for: unit) &#125; completionHandler(totalCalories, error as NSError?) &#125; self.healthStore?.execute(query)&#125;func predicateForSamplesToday() -&gt; NSPredicate &#123; let calendar = Calendar.current let now = Date() let startDate: Date? = calendar.startOfDay(for: now) let endDate: Date? = calendar.date(byAdding: .day, value: 1, to: startDate!) return HKQuery.predicateForSamples(withStart: startDate, end: endDate, options: .strictStartDate)&#125; 写入数据123456789101112131415161718192021222324252627func addstep(withStepNum stepNum: Double) &#123; let stepCorrelationItem: HKQuantitySample? = self.stepCorrelation(withStepNum: stepNum) self.healthStore?.save(stepCorrelationItem!, withCompletion: &#123; (success, error) in DispatchQueue.main.async(execute: &#123;() -&gt; Void in if success &#123; self.view.endEditing(true) self.addStepsTextField.text = "" self.refreshSteps() let alert = UIAlertController(title: "提示", message: "添加步数成功", defaultActionButtonTitle: "确定", tintColor: UIColor.red) alert.show() &#125; else &#123; let alert = UIAlertController(title: "提示", message: "添加步数失败", defaultActionButtonTitle: "确定", tintColor: UIColor.red) alert.show() return &#125; &#125;) &#125;)&#125;func stepCorrelation(withStepNum stepNum: Double) -&gt; HKQuantitySample &#123; let endDate = Date() let startDate = Date(timeInterval: -300, since: endDate) let stepQuantityConsumed = HKQuantity(unit: HKUnit.count(), doubleValue: stepNum) let stepConsumedType = HKQuantityType.quantityType(forIdentifier: .stepCount) let stepConsumedSample = HKQuantitySample(type: stepConsumedType!, quantity: stepQuantityConsumed, start: startDate, end: endDate, metadata: nil) return stepConsumedSample&#125; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android和iOS音频互通]]></title>
      <url>%2F2016%2F12%2F01%2FAndroid%E5%92%8CiOS%E9%9F%B3%E9%A2%91%E4%BA%92%E9%80%9A%2F</url>
      <content type="text"><![CDATA[最近项目中遇到一个问题,Android发送的音频文件在iOS端无法播放,音频格式是AMR,iOS端在将ARM格式转换成WAV格式时失败,用的是libopencore-amrnb库后来发现,是Android端转换的AMR和我们这边转换的不一样,虽然后缀都是.amr,但是Android转换出来的详细信息和我们的不一样 下面是Android端需要设置的代码1234567mRecorder = new MediaRecorder();mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);mRecorder.setOutputFormat(MediaRecorder.OutputFormat.AMR_NB);mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);# mRecorder.setAudioChannels(1);# mRecorder.setAudioSamplingRate(8000);# mRecorder.setAudioEncodingBitRate(64); 1.其中setOutputFormat和setAudioEncoder中一定要设置统一都为AMR_NB2.后三行一定不要写哦]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[deinit不执行的问题]]></title>
      <url>%2F2016%2F11%2F25%2Fdeinit%E4%B8%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[在Objective-C语法中,我们确定一个视图是否销毁可以通过dealloc方法查看,而Swift中没有此方法,不过提供deinit等同于dealloc最近写了个demo,过程中发现视图一直不执行deinit的方法,也就是说视图没有释放,查看了一下代码,发现代码中有一处比较可以,那就是写了个protocol,相互持有无法释放 解决办法给其中一个delegate添加weak来打破持有1weak var myDelegate: naviDelegate? 这时候delegate就需要定义为类protocol123protocol naviDelegate: class &#123;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[沙盒文件操作]]></title>
      <url>%2F2016%2F11%2F23%2F%E6%B2%99%E7%9B%92%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[沙盒文件主要有三个目录:1.Documents2.Library (Caches, Preferences)3.tmp 沙盒文件Documents苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下，iTunes备份和恢复的时候会包含此目录1234let homeDirectory = NSHomeDirectory()let documentPath = homeDirectory + "/Documents"let documentPath2 = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).firstprint("documentPath: \(documentPath) \n documentPath2: \(documentPath2)") Library这个目录下有2个子目录：Caches缓存 , Preferences偏好设置,不应该直接创建偏好设置文件而使用NSUserDefaults类1234// lib目录let LibraryPath = homeDirectory + "/Library/"let libraryPath2 = NSSearchPathForDirectoriesInDomains(.libraryDirectory, .userDomainMask, true).firstprint("LibraryPath: \(LibraryPath) \n LibraryPath2: \(libraryPath2)") 主要存放缓存文件，iTunes不会备份此目录，此目录下文件不会在应用退出时删除1234// Caches目录let libraryCachesPath = homeDirectory + "/Library/Caches"let libraryCachesPath2 = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true)print("libraryCachesPath: \(libraryCachesPath) \n libraryCachesPath2: \(libraryCachesPath2)") tmp用于存放临时文件，保持应用程序再次启动过程中不需要的信息，重启后清空123let temp = homeDirectory + "/tmp"let temp2 = NSTemporaryDirectory()print("temp: \(temp) \n temp2: \(temp2)") 文件操作1let fileManager = FileManager.default 自定义存储位置123456let customDir = NSHomeDirectory() + "/Documents/customInfo"do &#123; try fileManager.createDirectory(atPath: customDir, withIntermediateDirectories: true, attributes: nil)&#125; catch &#123; print("创建文件失败: \(error)")&#125; 注: withIntermediateDirectories设置为true表示中间目录不存在都会自动创建 保存文本信息到目录中1234567let customInfo = "xiaozhuzhu222"let customTxtPath = customDir + "/customTxt.txt"do &#123; try customInfo.write(toFile: customTxtPath, atomically: true, encoding: .utf8)&#125; catch &#123; print("写入文本失败: \(error)")&#125; 保存数组到目录中123let customArray = ["OC", "Swift", "Android", "JAVA", "iOS"] as NSArraylet customArrayPath = customDir + "/array.plist"customArray.write(toFile: customArrayPath, atomically: true) 保存字典到目录123let customDict = ["name": "xiaoxiong", "age": 18] as NSDictionarylet customDictPath = customDir + "/dict.plist"customDict.write(toFile: customDictPath, atomically: true) 保存data到目录中1234567891011let image = UIImage(named: "sfa.png")if let image = image &#123; let customData = UIImageJPEGRepresentation(image, 0.5) do &#123; let customDataPath = customDir + "/data.jpg" let dataUrl = URL(fileURLWithPath: customDataPath) try customData?.write(to: dataUrl) &#125; catch &#123; print("保存Data失败: \(error)") &#125;&#125; 判断目录是否存在1let isExist = fileManager.fileExists(atPath: customTxtPath) 移动文件内容123456let targetPath = customDir + "/target.txt"do &#123; try fileManager.moveItem(atPath: customTxtPath, toPath: targetPath)&#125; catch &#123; print("移动失败: \(error)")&#125; 获取目录下的所有文件12let fileArray = fileManager.subpaths(atPath: customDir)print("customInfo目录下的所有文件: \(fileArray)") 删除文件12345do &#123; try fileManager.removeItem(atPath: targetPath)&#125; catch &#123; print("删除文件失败: \(error)")&#125; 删除目录下的所有文件1234567do &#123; try fileArray?.forEach(&#123; (item) in try fileManager.removeItem(atPath: customDir + "/\(item)") &#125;)&#125; catch &#123; print("删除失败: \(error)")&#125; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Carthage安装使用]]></title>
      <url>%2F2016%2F11%2F21%2FCarthage%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Carthage依赖库管理工具,同cocoapods一样能够很好地管理我们的三方库资源,同时又有许多优于cocoapods的地方,越来越多的三方库开始支持Carthage集成了,目前项目开始起用Swift了,也换个依赖库管理工具,换个心情. 更新Homebrew $ brew update 安装Carthage安装 $ brew install carthage 查看版本 $ carthage version 升级 $ upgrade carthage 卸载 $ brew uninstall carthage 使用创建空的Cartfile touch Cartfile 打开Cartfile文件 open -a Xcode Cartfile 添加依赖库 github “Alamofire/Alamofire” ~&gt; 4.0 安装三方库 $ carthage update (指定平台安装 carthage update –platform iOS) Xcode配置添加 配置选择菜单Build Phases 添加新的Run Script 并添加一下命令 /usr/local/bin/carthage copy-frameworks 点击Input Files下面+号,添加每一个Framework条目 $(SRCROOT)/Carthage/Build/iOS/Alamofire.framework]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片尺寸]]></title>
      <url>%2F2016%2F11%2F19%2F%E5%9B%BE%E7%89%87%E5%B0%BA%E5%AF%B8%2F</url>
      <content type="text"><![CDATA[Android &amp; iOS设计尺寸规范 开发群里发现的图,拿来一用,平时自己看看 看不清可点击后放大 点击我]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[直播 LFLiveKit推流+ ijkplayer播放 + mac搭建直播环境]]></title>
      <url>%2F2016%2F11%2F17%2FDNLiveDemo%2F</url>
      <content type="text"><![CDATA[简介通过LFLiveKit推流+ijkplayer播放的方式实现客户端简单直播,同时在mac电脑上搭建环境,通过vlc播放器在电脑上播放 主要用到的技术 推流: LFLiveKit 播放: ijkplayer 服务器: nginx+rtmp+ffmpeg 推流LFLiveKit OC编写,使用的是HlS (HTTP Live Streaming),集成GPUImage美颜等直播常用功能,支持cocoapods导入 LFLiveKit基本使用具体用法可查看demo 源码下载 申请摄像头和麦克风访问权限12345678910111213141516171819// 请求访问摄像头func requestAccessForVideo() -&gt; Void &#123; let status = AVCaptureDevice.authorizationStatus(forMediaType: AVMediaTypeVideo); switch status &#123; // 许可对话没有出现，发起授权许可 case .notDetermined: AVCaptureDevice.requestAccess(forMediaType: AVMediaTypeVideo, completionHandler: &#123; (granted) in if(granted)&#123; DispatchQueue.main.async &#123; self.session.running = true &#125; &#125; &#125;) case .authorized:// 已经开启授权，可继续 session.running = true case .denied: break// 用户明确地拒绝授权，或者相机设备无法访问 case .restricted: break &#125;&#125; 1234567891011121314// 请求访问麦克风func requestAccessForAudio() -&gt; Void &#123; let status = AVCaptureDevice.authorizationStatus(forMediaType:AVMediaTypeAudio) switch status &#123; case .notDetermined:// 许可对话没有出现，发起授权许可 AVCaptureDevice.requestAccess(forMediaType: AVMediaTypeAudio, completionHandler: &#123; (granted) in &#125;) case .authorized: break;// 已经开启授权，可继续 // 用户明确地拒绝授权，或者相机设备无法访问 case .denied: break case .restricted:break; &#125;&#125; 初始化12345678lazy var session: LFLiveSession = &#123; let audioConfiguration = LFLiveAudioConfiguration.defaultConfiguration(for: .high) let videoConfiguration = LFLiveVideoConfiguration.defaultConfiguration(for: .low3) let session = LFLiveSession(audioConfiguration: audioConfiguration, videoConfiguration: videoConfiguration) session?.delegate = self session?.preView = self.view return session!&#125;() 开始直播结束直播12345678910// 开始直播func startLive() &#123; let stream = LFLiveStreamInfo() stream.url = "rtmp://192.168.3.242:1935/rtmplive/room" session.startLive(stream)&#125;func stopLive() -&gt; Void &#123; session.stopLive()&#125; LFLiveSessionDelegate代理回调123func liveSession(_ session: LFLiveSession?, debugInfo: LFLiveDebug?) &#123; print("debugInfo: \(debugInfo?.currentBandwidth)")&#125; 123func liveSession(_ session: LFLiveSession?, errorCode: LFLiveSocketErrorCode) &#123; print("errorCode: \(errorCode.rawValue)")&#125; 123456789101112131415func liveSession(_ session: LFLiveSession?, liveStateDidChange state: LFLiveState) &#123; print("liveStateDidChange: \(state.rawValue)") switch state &#123; case LFLiveState.ready: stateLabel.text = "未连接" case LFLiveState.pending: stateLabel.text = "连接中" case LFLiveState.start: stateLabel.text = "已连接" case LFLiveState.error: stateLabel.text = "连接错误" case LFLiveState.stop: stateLabel.text = "未连接" &#125;&#125; 播放ijkplayer: 基于FFmpeg的跨平台播放器 服务端nginx+rtmp+ffmpeg 安装Homebrew查询是否安装Homebrew $ man brew 如果安装输入q退出编辑 安装nginx $ brew tap homebrew/nginx$ brew install nginx-full –with-rtmp-module$ nginx$ brew info nginx-full 1.查看如图所示路径 2.输入命令进入该路径 $ vim /usr/local/etc/nginx/nginx.conf 在文件最后添加如下代码123456789rtmp &#123; server &#123; listen 1935; application rtmplive &#123; live on; record off; &#125; &#125;&#125; 3.重启nginx $ /usr/local/Cellar/nginx-full/1.10.2/bin/nginx -s reload 注:该命令中的1.10.2改成自己的版本号 安装ffmpeg $ brew install ffmpeg 耐心等待即可 将项目中的推流地址改成rtmp://192.168.3.242:1935/rtmplive/room其中的192.168.3.242为你电脑的网络ip,修改后,手机和电脑连接同一网络即可测试直播效果为了查看直播是否被推送过来,可下载支持rtmp协议的视频播放器VLC打开VCL 选择菜单File - Open Network 输入直播流地址即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二维码扫描识别生成]]></title>
      <url>%2F2016%2F11%2F16%2F%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E8%AF%86%E5%88%AB%E7%94%9F%E6%88%90%2F</url>
      <content type="text"><![CDATA[系统api实现二维码的扫描,识别,生成 配置需要配置文件权限 Privacy - Camera Usage DescriptionPrivacy - Camera Usage Description 导入头文件1import AVFoundation 二维码扫描定义摄像头12var session: AVCaptureSession!var layer: AVCaptureVideoPreviewLayer! 设置摄像头1234567891011121314151617181920212223242526272829303132333435363738394041func setupScanSession() &#123; // 获取摄像设备 let device = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeVideo) // 看看有没有可用摄像头,一般可能被用户取消授权需主动去设置界面开启 guard device != nil else &#123; let alertView = UIAlertView(title: "提示", message: "没有发现可用摄像设备", delegate: self, cancelButtonTitle: "确定") alertView.show() return &#125; // 初始化链接对象 session = AVCaptureSession() let input: AVCaptureDeviceInput? do &#123; input = try AVCaptureDeviceInput.init(device: device) &#125; catch &#123; print("输入流出问题了:\(error)") return &#125; // 设置会话的输入设备 if session.canAddInput(input) &#123; session.addInput(input) &#125; // 创建输出流 let output = AVCaptureMetadataOutput() // 设置代理, 在主线程里刷新 output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main) // 设置高质量采集率 session.canSetSessionPreset(AVCaptureSessionPresetHigh) if session.canAddOutput(output) &#123; session.addOutput(output) &#125; // 设置扫码支持的编码格式 (条形码和二维码) output.metadataObjectTypes = [AVMetadataObjectTypeQRCode,AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeCode128Code] layer = AVCaptureVideoPreviewLayer(session: session) layer.videoGravity = AVLayerVideoGravityResizeAspectFill // 设置相机扫描框大小 layer.frame = CGRect(x: 10, y: 100, width: 300, height: 300) self.view.layer.insertSublayer(layer, at: 0) // 开始扫描 startScan()&#125; 开始扫描123456fileprivate func startScan() &#123; guard let session = session else &#123; return &#125; if !session.isRunning &#123; session.startRunning() &#125;&#125; 扫码捕捉完成123456789101112131415//扫描捕捉完成extension ScanQRViewController : AVCaptureMetadataOutputObjectsDelegate &#123; func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!) &#123; // 停止扫码 session.stopRunning() // 开始对信息解读 var QRCodeMessage = "" for metaData in metadataObjects &#123; if (metaData as? AVMetadataObject)?.type == AVMetadataObjectTypeQRCode &#123; QRCodeMessage = ((metaData as? AVMetadataMachineReadableCodeObject)?.stringValue)! &#125; &#125; print("扫码结果\(QRCodeMessage)") &#125;&#125; 二维码识别UIImage扩展类实现12345678910111213extension UIImage &#123; /** 1.识别图片二维码 - returns: 二维码内容 */ func recognizeQRCode() -&gt; String? &#123; let detector = CIDetector(ofType: CIDetectorTypeQRCode, context: nil, options: [CIDetectorAccuracy : CIDetectorAccuracyHigh]) let features = detector?.features(in: CoreImage.CIImage(cgImage: self.cgImage!)) guard (features?.count)! &gt; 0 else &#123; return nil &#125; let feature = features?.first as? CIQRCodeFeature return feature?.messageString &#125;&#125; 调用123456let image = UIImage(named: "qrimage")DispatchQueue.global().async &#123; let recognizeResult = image?.recognizeQRCode() let result = (recognizeResult?.characters.count)! &gt; 0 ? recognizeResult : "无法识别" print(result)&#125; 二维码生成String扩展1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586extension String &#123; /** 生成二维码 - parameter size: 大小 - parameter color: 颜色 - parameter bgColor: 背景颜色 - parameter logo: 图标 - parameter radius: 圆角 - parameter borderLineWidth: 线宽 - parameter borderLineColor: 线颜色 - parameter boderWidth: 带宽 - parameter borderColor: 带颜色 - returns: 自定义二维码 */ func generateQRCode(size:CGFloat?,color:UIColor?,bgColor:UIColor?,logo:UIImage?,radius:CGFloat,borderLineWidth:CGFloat?,borderLineColor:UIColor?,boderWidth:CGFloat?,borderColor:UIColor?) -&gt; UIImage &#123; let ciImage = generateCIImage(size: size, color: color, bgColor: bgColor) let image = UIImage(ciImage: ciImage) guard let QRCodeLogo = logo else &#123; return image &#125; let logoWidth = image.size.width/4 let logoFrame = CGRect(x: (image.size.width - logoWidth) / 2, y: (image.size.width - logoWidth) / 2, width: logoWidth, height: logoWidth) // 绘制logo UIGraphicsBeginImageContextWithOptions(image.size, false, UIScreen.main.scale) image.draw(in: CGRect(x: 0, y: 0, width: image.size.width, height: image.size.height)) // 线框 let logoBorderLineImagae = QRCodeLogo.getRoundRectImage(size: logoWidth, radius: radius, borderWidth: borderLineWidth, borderColor: borderLineColor) // 边框 let logoBorderImagae = logoBorderLineImagae.getRoundRectImage(size: logoWidth, radius: radius, borderWidth: boderWidth, borderColor: borderColor) logoBorderImagae.draw(in: logoFrame) let QRCodeImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return QRCodeImage! &#125; /** 生成CIImage - parameter size: 大小 - parameter color: 颜色 - parameter bgColor: 背景颜色 - returns: CIImage */ func generateCIImage(size:CGFloat?,color:UIColor?,bgColor:UIColor?) -&gt; CIImage &#123; // 1.缺省值 var QRCodeSize : CGFloat = 300//默认300 var QRCodeColor = UIColor.black//默认黑色二维码 var QRCodeBgColor = UIColor.white//默认白色背景 if let size = size &#123; QRCodeSize = size &#125; if let color = color &#123; QRCodeColor = color &#125; if let bgColor = bgColor &#123; QRCodeBgColor = bgColor &#125; // 2.二维码滤镜 let contentData = self.data(using: String.Encoding.utf8) let fileter = CIFilter(name: "CIQRCodeGenerator") fileter?.setValue(contentData, forKey: "inputMessage") fileter?.setValue("H", forKey: "inputCorrectionLevel") let ciImage = fileter?.outputImage // 3.颜色滤镜 let colorFilter = CIFilter(name: "CIFalseColor") colorFilter?.setValue(ciImage, forKey: "inputImage") colorFilter?.setValue(CIColor(cgColor: QRCodeColor.cgColor), forKey: "inputColor0")// 二维码颜色 colorFilter?.setValue(CIColor(cgColor: QRCodeBgColor.cgColor), forKey: "inputColor1")// 背景色 // 4.生成处理 let outImage = colorFilter!.outputImage let scale = QRCodeSize / outImage!.extent.size.width; let transform = CGAffineTransform(scaleX: scale, y: scale) let transformImage = colorFilter!.outputImage!.applying(transform) return transformImage &#125;&#125; UIImage扩展类12345678910111213141516171819202122232425262728293031323334353637extension UIImage &#123; // 获取圆角图片 func getRoundRectImage(size:CGFloat,radius:CGFloat) -&gt; UIImage &#123; return getRoundRectImage(size: size, radius: radius, borderWidth: nil, borderColor: nil) &#125; // 获取圆角图片(带边框) func getRoundRectImage(size:CGFloat,radius:CGFloat,borderWidth:CGFloat?,borderColor:UIColor?) -&gt; UIImage &#123; let scale = self.size.width / size ; // 初始值 var defaultBorderWidth : CGFloat = 0 var defaultBorderColor = UIColor.clear if let borderWidth = borderWidth &#123; defaultBorderWidth = borderWidth * scale &#125; if let borderColor = borderColor &#123; defaultBorderColor = borderColor &#125; let radius = radius * scale let react = CGRect(x: defaultBorderWidth, y: defaultBorderWidth, width: self.size.width - 2 * defaultBorderWidth, height: self.size.height - 2 * defaultBorderWidth) // 绘制图片设置 UIGraphicsBeginImageContextWithOptions(self.size, false, UIScreen.main.scale) let path = UIBezierPath(roundedRect:react , cornerRadius: radius) // 绘制边框 path.lineWidth = defaultBorderWidth defaultBorderColor.setStroke() path.stroke() path.addClip() // 画图片 draw(in: react) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage!; &#125;&#125; 使用12let url = "http://www.baidu.com"let image = url.generateQRCode() 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS10新特性之语音识别]]></title>
      <url>%2F2016%2F11%2F15%2FiOS10%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%2F</url>
      <content type="text"><![CDATA[SpeechRecognition简介iOS10引入了一个新的API: Speech.framework,语音识别功能,可以执行语音转录实时和记录音频,有了这个,妈妈再也不用担心我语音识别了,告别科大讯飞也不远了吧. 配置在使用系统提供的功能时需要在plist文件中配置权限,这里需要两个权限:语音识别,麦克风 Privacy - Microphone Usage DescriptionPrivacy - Speech Recognition Usage Description 用户启动后会显示的授权界面 使用定义用到的属性1234private var audioEngine: AVAudioEngine!private var speechRecognizer: SFSpeechRecognizer!private var speechRequest: SFSpeechAudioBufferRecognitionRequest!private var currentSpeechTask: SFSpeechRecognitionTask! 初始化授权123456789101112131415161718self.audioEngine = AVAudioEngine()self.speechRecognizer = SFSpeechRecognizer()self.micButton.isEnabled = false;SFSpeechRecognizer.requestAuthorization &#123; (status) in guard status == .authorized else &#123;// 用户授权判断 return; &#125; // 初始化语音处理器的输入模式 let myFormat = self.audioEngine.inputNode?.outputFormat(forBus: 0) self.audioEngine.inputNode?.installTap(onBus: 0, bufferSize: 1024, format: myFormat, block: &#123; (buffer, time) in // 为语音识别请求对象添加一个AudioPCMBuffer，来获取声音数据 self.speechRequest.append(buffer) &#125;) // 语音处理器准备就绪（会为一些audioEngine启动时所必须的资源开辟内存） self.audioEngine.prepare() self.micButton.isEnabled = true&#125; 开始录制1234567891011121314151617181920func startDictating() &#123; do &#123; // 启动声音处理器 try self.audioEngine.start() // 初始化 self.speechRequest = SFSpeechAudioBufferRecognitionRequest() // 使用speechRequest请求进行识别 self.currentSpeechTask = self.speechRecognizer.recognitionTask(with: self.speechRequest, resultHandler: &#123; (result, error) in // 识别结果 guard result != nil else &#123; return &#125; self.contentLabel.text = result?.bestTranscription.formattedString; &#125;) &#125; catch &#123; print("开启失败: \(error)") &#125;&#125; 停止录制1234func stopDictating() &#123; self.audioEngine.stop() self.speechRequest.endAudio()&#125; UI123456789101112@IBAction func micBtnClick(_ sender: UIButton) &#123; if self.currentSpeechTask.state == .running &#123; self.micButton.setTitle("开始", for: .normal) // 停止语音识别 self.stopDictating() &#125; else &#123; self.micButton.setTitle("停止", for: .normal) self.contentLabel.text = "等待识别" // 开始语音识别 self.startDictating() &#125;&#125; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Alamofire网络请求库的使用]]></title>
      <url>%2F2016%2F11%2F11%2FAlamofire%E7%BD%91%E8%B7%AF%E8%AF%B7%E6%B1%82%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Alamofire是目前星星最多的Swift网络请求库,作者和著名的AFNetworking是一个人,接下来介绍一下具体使用方法 准备和介绍支持版本 iOS 9.0+ / macOS 10.11+ / tvOS 9.0+ / watchOS 2.0+Xcode 8.0+Swift 3.0+ 安装我们通常直接用cocoapods安装,省时省力,cocoapods使用可以看上一篇文章 source ‘https://github.com/CocoaPods/Specs.git‘platform :ios, ‘10.0’use_frameworks! target ‘‘ dopod ‘Alamofire’, ‘~&gt; 4.0’end 使用发送请求12import AlamofireAlamofire.request("https://httpbin.org/get") 请求响应12345678910Alamofire.request("https://httpbin.org/get").responseJSON &#123; (response) in print(response.request) // 原请求链接 print(response.response) // 请求响应 print(response.data) // 服务器数据 print(response.result) // 返回结果 if let JSON = response.result.value &#123; print("JSON: \(JSON)") &#125;&#125; Alamofire默认提供5中响应处理1.Response(不推荐)1234func response( queue: DispatchQueue?, completionHandler: @escaping (DefaultDownloadResponse) -&gt; Void) -&gt; Self 对返回的数据不做任何处理123456789Alamofire.request("https://httpbin.org/get").response &#123; (response) in print("Request: \(response.request)") print("Response: \(response.response)") print("error: \(response.error)") if let data = response.data, let utf8Text = String(data: data, encoding: .utf8) &#123; print("Data: \(utf8Text)") &#125;&#125; 2.Response Data1234func responseData( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Data&gt;) -&gt; Void) -&gt; Self 如果返回结果没有出现错误,返回的result是.success和data类型的value1234567Alamofire.request("https://httpbin.org/get").responseData &#123; (response) in print("All Response Info: \(response)") if let data = response.result.value, let utf8Text = String(data: data, encoding: .utf8) &#123; print("Data: \(utf8Text)") &#125;&#125; 3.Response String12345func responseString( queue: DispatchQueue?, encoding: String.Encoding?, completionHandler: @escaping (DataResponse&lt;String&gt;) -&gt; Void) -&gt; Self 如果返回结果没有出现错误,返回的result是.success和String类型的value1234Alamofire.request("https://httpbin.org/get").responseString &#123; response in print("Success: \(response.result.isSuccess)") print("Response String: \(response.result.value)")&#125; 4.Response JSON1234func responseJSON( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Any&gt;) -&gt; Void) -&gt; Self 如果返回结果没有出现错误,返回的result是.success和Any类型的value12345Alamofire.request("https://httpbin.org/get").responseJSON &#123; response in if let json = response.result.value &#123; print("JSON: \(json)") &#125;&#125; 5.Response PropertyList (plist)1234func responsePropertyList( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Any&gt;) -&gt; Void)) -&gt; Self 响应链可以多个响应方式链式调用1234567Alamofire.request("https://httpbin.org/get") .responseString &#123; (response) in print("Response String: \(response.result.value)")&#125; .responseJSON &#123; (response) in print("Response JSON: \(response.result.value)")&#125; 请求队列默认情况下,请求是在主队列中进行的,我们可以自己定制队列1234let utilityQueue = DispatchQueue.global(qos: .utility)Alamofire.request("https://httpbin.org/get").responseJSON(queue: utilityQueue) &#123; (response) in print("Executing response handler on utility queue")&#125; 响应验证手动校验1234567891011Alamofire.request("https://httpbin.org/get") .validate(statusCode: 200..&lt;300) .validate(contentType: ["application/json"]) .responseData &#123; (response) in switch response.result &#123; case .success: print("验证成功") case .failure: print("验证失败") &#125;&#125; 自动校验自动校验状态码范围200…299, 并且该Content-Type与请求头一致12345678Alamofire.request("https://httpbin.org/get").validate().responseJSON &#123; response in switch response.result &#123; case .success: print("校验成功") case .failure(let error): print("校验失败: \(error)") &#125;&#125; HTPP请求方法1234567891011public enum HTTPMethod: String &#123; case options = "OPTIONS" case get = "GET" case head = "HEAD" case post = "POST" case put = "PUT" case patch = "PATCH" case delete = "DELETE" case trace = "TRACE" case connect = "CONNECT"&#125; 这些值可以作为参数传递1234Alamofire.request("https://httpbin.org/get") Alamofire.request("https://httpbin.org/post", method: .post)Alamofire.request("https://httpbin.org/put", method: .put)Alamofire.request("https://httpbin.org/delete", method: .delete) Alamofire.request默认方法参数是 .get 参数编码Alamofire支持3种编码 URL JSON PropertyList 1.URL编码Get请求URL编码参数12345678let parameters: Parameters = ["foo": "bar"]// 下面三种写法等价 Alamofire.request("https://httpbin.org/get", parameters: parameters) // encoding defaults to `URLEncoding.default`Alamofire.request("https://httpbin.org/get", parameters: parameters, encoding: URLEncoding.default)Alamofire.request("https://httpbin.org/get", parameters: parameters, encoding: URLEncoding(destination: .methodDependent))// https://httpbin.org/get?foo=bar Post请求URL编码参数12345678910111213141516let parameters: Parameters = [ "foo": "bar", "baz": ["a", 1], "qux": [ "x": 1, "y": 2, "z": 3 ]]// 下面三种写法等价 Alamofire.request("https://httpbin.org/post", parameters: parameters)Alamofire.request("https://httpbin.org/post", parameters: parameters, encoding: URLEncoding.default)Alamofire.request("https://httpbin.org/post", parameters: parameters, encoding: URLEncoding.httpBody)// HTTP body: foo=bar&amp;baz[]=a&amp;baz[]=1&amp;qux[x]=1&amp;qux[y]=2&amp;qux[z]=3 2.JSON编码123456789101112let parameters: Parameters = [ "foo": [1,2,3], "bar": [ "baz": "qux" ]]// 两种写法等价Alamofire.request("https://httpbin.org/post", method: .post, parameters: parameters, encoding: JSONEncoding.default)Alamofire.request("https://httpbin.org/post", method: .post, parameters: parameters, encoding: JSONEncoding(options: []))// HTTP body: &#123;"foo": [1, 2, 3], "bar": &#123;"baz": "qux"&#125;&#125; 3.Property List编码当ParameterEncoding类型不能满足需求时,可以创建自定义编码1234567891011121314151617struct JSONStringArrayEncoding: ParameterEncoding &#123; private let array: [String] init(array: [String]) &#123; self.array = array &#125; func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -&gt; URLRequest &#123; var urlRequest = urlRequest.urlRequest let data = try JSONSerialization.data(withJSONObject: array, options: []) if urlRequest.value(forHTTPHeaderField: "Content-Type") == nil &#123; urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type") &#125; urlRequest.httpBody = data return urlRequest &#125;&#125; HTTP请求头12345678let headers: HTTPHeaders = [ "Authorization": "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==", "Accept": "application/json"]Alamofire.request("https://httpbin.org/headers", headers: headers).responseJSON &#123; response in debugPrint(response)&#125; 认证认证是由系统框架层处理URLCredential和URLAuthenticationChallenge。 1.基本认证1234567let user = "user"let password = "password"Alamofire.request("https://httpbin.org/basic-auth/\(user)/\(password)") .authenticate(user: user, password: password) .responseJSON &#123; (response) in debugPrint(response)&#125; 放在请求头中也能达到该效果123456789101112let user = "user"let password = "password"var headers: HTTPHeaders = [:]if let authorizationHeader = Request.authorizationHeader(user: user, password: password) &#123; headers[authorizationHeader.key] = authorizationHeader.value&#125;Alamofire.request("https://httpbin.org/basic-auth/user/password", headers: headers) .responseJSON &#123; response in debugPrint(response)&#125; 2.URLCredential认证123456789let user = "user"let password = "password"let credential = URLCredential(user: user, password: password, persistence: .forSession)Alamofire.request("https://httpbin.org/basic-auth/\(user)/\(password)") .authenticate(usingCredential: credential) .responseJSON &#123; response in debugPrint(response)&#125; 下载数据到文件夹12345Alamofire.download("https://httpbin.org/image/png").responseData &#123; (response) in if let data = response.result.value &#123; let image = UIImage(data: data) &#125;&#125; 下载到执行文件夹中1234567891011121314let destination: DownloadRequest.DownloadFileDestination = &#123; _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent("pig.png") return (fileURL, [.removePreviousFile, .createIntermediateDirectories])&#125;Alamofire.download(urlString, to: destination).response &#123; response in print(response) if response.error == nil, let imagePath = response.destinationURL?.path &#123; let image = UIImage(contentsOfFile: imagePath) &#125;&#125; 下载到建议的目录下12let destination = DownloadRequest.suggestedDownloadDestination(for: .documentDirectory)Alamofire.download("https://httpbin.org/image/png", to: destination) 下载进度123456789Alamofire.download("https://httpbin.org/image/png") .downloadProgress &#123; progress in print("下载进度: \(progress.fractionCompleted)") &#125; .responseData &#123; response in if let data = response.result.value &#123; let image = UIImage(data: data) &#125;&#125; 来个线程1234567891011let utilityQueue = DispatchQueue.global(qos: .utility)Alamofire.download("https://httpbin.org/image/png") .downloadProgress(queue: utilityQueue) &#123; progress in print("Download Progress: \(progress.fractionCompleted)") &#125; .responseData &#123; response in if let data = response.result.value &#123; let image = UIImage(data: data) &#125;&#125; 恢复下载有时候我们在下载的时候可能会取消或者中断了,这时候下次可能需要接着下载,这时候就需要恢复下载1234567891011121314151617181920212223242526272829303132class ImageRequestor &#123; private var resumeData: Data? private var image: UIImage? func fetchImage(completion: (UIImage?) -&gt; Void) &#123; guard image == nil else &#123; completion(image) ; return &#125; let destination: DownloadRequest.DownloadFileDestination = &#123; _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent("pig.png") return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) &#125; let request: DownloadRequest if let resumeData = resumeData &#123; request = Alamofire.download(resumingWith: resumeData) &#125; else &#123; request = Alamofire.download("https://httpbin.org/image/png") &#125; request.responseData &#123; response in switch response.result &#123; case .success(let data): self.image = UIImage(data: data) case .failure: self.resumeData = response.resumeData &#125; &#125; &#125;&#125; 上传文件1.上传Data文件1234let imageData = UIImagePNGRepresentation(image)!Alamofire.upload(imageData, to: "https://httpbin.org/post").responseJSON &#123; response in debugPrint(response)&#125; 2.上传File1234let fileURL = Bundle.main.url(forResource: "video", withExtension: "mov")!Alamofire.upload(fileURL, to: "https://httpbin.org/post").responseJSON &#123; response in debugPrint(response)&#125; 3.上传多文件1234567891011121314151617Alamofire.upload( multipartFormData: &#123; multipartFormData in multipartFormData.append(ImageURL1, withName: "image1") multipartFormData.append(ImageURL2, withName: "image2") &#125;, to: "https://httpbin.org/post", encodingCompletion: &#123; encodingResult in switch encodingResult &#123; case .success(let upload, _, _): upload.responseJSON &#123; response in debugPrint(response) &#125; case .failure(let encodingError): print(encodingError) &#125; &#125;) 4.上传进度123456789101112let fileURL = Bundle.main.url(forResource: "video", withExtension: "mov")!Alamofire.upload(fileURL, to: "https://httpbin.org/post") .uploadProgress &#123; progress in print("上传进度: \(progress.fractionCompleted)") &#125; .downloadProgress &#123; progress in print("下载进度: \(progress.fractionCompleted)") &#125; .responseJSON &#123; response in debugPrint(response)&#125; 证书验证12345let serverTrustPolicy = ServerTrustPolicy.pinCertificates( certificates: ServerTrustPolicy.certificatesInBundle(), validateCertificateChain: true, validateHost: true) 基本用法先介绍到这里,下篇将仔细整理HTTPS以及验证证书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GCD Swift3.0]]></title>
      <url>%2F2016%2F11%2F09%2FGCD-Swift3-0%2F</url>
      <content type="text"><![CDATA[Swift3.0之后GCD的写法是越来越简单,以下是平时项目开发中可能会遇到的多线程操作,现在整理一起方便以后查阅. 基本分类队列执行任务分为 同步:在当前线程中执行,执行完才会执行下一条命令,会阻塞当前线程异步:在另一个线程中执行,下一条命令不许要等该线程执行完,不会阻塞当前线程 队列分类 串行队列:让任务一个接一个的执行并发队列:多个任务同时进行,只有在异步函数下才有效 创建分类创建串行队列1let serial = DispatchQueue(label: "serialqueue1") 创建并行队列12345let concurrent = DispatchQueue(label: "concurrentqueue1", qos: .userInitiated, attributes: .concurrent, autoreleaseFrequency: .workItem, target: nil) 参数说明 1.label 队列名称2.qos 设置优先级 (默认是 default) .background : 后台(非常耗时的不重要的操作放在这里,执行完调用主线程) .utility : 低 .default : 正常的 .userInitiated : 高(不要放太耗时的操作) .userInteractive : 用户交互(跟主线程一样) .unspecified : 不指定 3.attributes 队列类型 .concurrent : 并行队列 .initiallyInactive : 与线程优先级有关 获取系统队列获取系统存在的全局队列,可设置优先级1let globalQueue = DispatchQueue.global(qos: .default) 获取系统主线程,跟UI有关的操作需要放在主线程中执行1let mainQueue = DispatchQueue.main 队列操作添加任务到队列中异步123456DispatchQueue.global(qos: .default).async &#123; print("耗时操作") DispatchQueue.main.async &#123; print("耗时操作完,回调主线程刷新界面") &#125;&#125; 同步12345678// 全局线程DispatchQueue.global(qos: .default).sync &#123; print("我在全局队列中执行同步操作")&#125;// 主线程执行同步会引起死锁DispatchQueue.main.sync &#123; print("我在主线程中执行同步操作")&#125; 暂停、继续队列1234567891011let concurrentQueue = DispatchQueue(label: "queue2", attributes: .concurrent)concurrentQueue.async &#123; (1...100000000000000000).forEach(&#123; (index) in print(index) &#125;)&#125;// 暂停concurrentQueue.suspend()sleep(2)// 继续concurrentQueue.resume() 延时操作123DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) &#123; print("我延时两秒执行")&#125; 只执行一次12345678910private var once1:Void = &#123; //只执行一次 print("once1")&#125;()private lazy var once2:String = &#123; //只执行一次，可用于创建单例 print("once2") return "once2"&#125;() Group的用法1234567891011121314151617181920212223// 获取全局队列let queue = DispatchQueue.global()// 创建grouplet group = DispatchGroup()// 并发queue.async(group: group, qos: .default, flags: .barrier) &#123; sleep(2) print("我是第一吗")&#125;queue.async(group: group, qos: .default, flags: .barrier) &#123; sleep(2) print("我是第二吗")&#125;queue.async(group: group, qos: .default, flags: .barrier) &#123; sleep(2) print("我是第三吗")&#125;// 不阻塞主线程group.notify(queue: queue) &#123; print("大家都执行完毕了吧")&#125;如果有多个并发队列在一个组里，我们想在这些操作执行完了再继续，调用waitgroup.wait() 指定多次Block到队列中123456789let queue2 = DispatchQueue.global()queue2.async &#123; DispatchQueue.concurrentPerform(iterations: 3, execute: &#123; (index) in print(index) &#125;) DispatchQueue.main.async &#123; print("执行完毕,在主线程中刷新") &#125;&#125; 信号量为了线程安全的统计数量，我们会使用信号量作计数。1234567891011let queue3 = DispatchQueue.global(qos: .default)let semaphore = DispatchSemaphore(value: 1)(1...1000).forEach &#123; (index) in queue3.async &#123; // 信号量减一, semaphore.wait() print(index) // 信号量加一 semaphore.signal() &#125;&#125; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swift3.0新特性]]></title>
      <url>%2F2016%2F11%2F07%2Fswift3-0%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
      <content type="text"><![CDATA[自 Swift 开源以来，Swift 的开发与演变已经完全由社区和核心团队所共同主导，它们在 Swift 3 当中为我们带来了巨大的变化和改进，而这正是我们所需要详细了解的 彻底移除在 Swift 2.2 就已经弃用的特性弃用 ++ 与 – 操作符过去我们可以使用 ++ 与 – 操作符来实现自增自减，现已废弃。12345var i = 0i++++ii----i 可以使用复合加法运算（+=）与减法运算（-=），或者使用普通的加法运算（+）与减法运算（-）实现同样的功能。12345678//使用复合加法运算（+=）与减法运算（-=）var i = 0i += 1i -= 1//使用普通的加法运算（+）与减法运算（-）i = i + 1i = i - 1 废除C语言风格的for循环我们过去可能习惯下面风格的 for 循环，现在也已废弃。123for var i=1; i&lt;100; i++ &#123;print("\(i)")&#125; 现在可以使用 for-in 循环，或者使用 for-each 加闭包的写法实现同样的功能。123456789//for-in循环for i in 1...10 &#123;print(i)&#125;//for-each循环(1...10).forEach &#123;print($0)&#125; 移除函数参数的 var 标记在 Swift 函数中，参数默认是常量。过去可以在参数前加关键字 var 将其定义为变量，这样函数内部就可以对该参数进行修改（外部的参数任然不会被修改）。123456var age = 22add(age)func add(var age:Int) &#123;age += 1&#125; 现在这种做法已经被废弃，Swift 3 不再允许开发者这样来将参数标记为变量了。 所有函数参数都必须带上标签过去如果一个函数有多个参数，调用的时候第一个参数无需带标签，而从第二个参数开始，必须要带标签。12345let number = additive(8, b: 12)func additive(a:Int, b:Int) -&gt; Int&#123; return a + b&#125; 现在为了确保函数参数标签的一致性，所有参数都必须带上标签。12345let number = additive(a: 8, b: 12)func additive(a:Int, b:Int) -&gt; Int&#123; return a + b&#125; 这个变化可能会造成我们的项目代码要进行较大的改动，毕竟涉及的地方很多。所以苹果又给出了一种不用给第一个参数带标签的解决方案。即在第一个参数前面加上一个下划线。（不过这个只是方便我们代码从 Swift2 迁移到 Swift3 的一个折中方案，可以的话还是建议将所有的参数都带上标签。）12345let number = additive(8, b: 12)func additive(_ a:Int, b:Int) -&gt; Int&#123; return a + b&#125; 函数声明和函数调用都需要括号来包括参数我们可以使用函数类型作为参数 ，对于一个参数是函数、返回值也是函数的函数。原来我们可能会这么写：1func g(a: Int -&gt; Int) -&gt; Int-&gt;Int &#123; ... &#125; 当这样非常难以阅读，很难看出参数在哪里结束，返回值又从哪里开始。在 Swift 3 中变成这么定义这个函数：1func g(a:(Int) -&gt; Int) -&gt; (Int) -&gt; Int &#123; ... &#125; Selector 不再允许使用 String假设我们给按钮添加一个点击事件响应，点击后执行 tapped 函数。以前可以这么写：1button.addTarget(responder, action: "tapped", forControlEvents: .TouchUpInside) 但由于按钮的 selector 写的是字符串。如果字符串拼写错了，那程序会在运行时因找不到相关方法而崩溃。所以 Swift 3 将这种写法废除，改成 #selecor()。这样就将允许编译器提前检查方法名的拼写问题，而不用再等到运行时才发现问题。1button.addTarget(self, action:#selector(tapped), for:.touchUpInside) Swift 3 的新特性内联序列函数sequenceSwift 3 新增了两个全局函数：sequence(first: next:) 和 sequence(state: next:)。使用它们可以返回一个无限序列。下面是一个简单的使用样例123456789// 从某一个树节点一直向上遍历到根节点for node in sequence(first: leaf, next: &#123; $0.parent &#125;) &#123; // node is leaf, then leaf.parent, then leaf.parent.parent, etc.&#125;// 遍历出所有的2的n次方数（不考虑溢出）for value in sequence(first: 1, next: &#123; $0 * 2 &#125;) &#123; // value is 1, then 2, then 4, then 8, etc.&#125; key-path不再只能使用String这个是用在键值编码（KVC）与键值观察（KVO）上的我们还是可以继续使用 String 类型的 key-Path：1234567891011121314151617//用户类class User: NSObject&#123; var name:String = "" //姓名 var age:Int = 0 //年龄&#125;//创建一个User实例对象let user1 = User()user1.name = "hangge"user1.age = 100//使用KVC取值let name = user1.value(forKey: "name")print(name)//使用KVC赋值user1.setValue("hangge.com", forKey: "name") 但建议使用新增的 #keyPath() 写法，这样可以避免我们因为拼写错误而引发问题。123456//使用KVC取值let name = user1.value(forKeyPath: #keyPath(User.name))print(name)//使用KVC赋值user1.setValue("hangge.com", forKeyPath: #keyPath(User.name)) Foundation 去掉 NS 前缀比如过去我们使用 Foundation 相关类来对文件中的 JSON 数据进行解析，这么写：12345let file = NSBundle.mainBundle().pathForResource("tutorials", ofType: "json")let url = NSURL(fileURLWithPath: file!)let data = NSData(contentsOfURL: url)let json = try! NSJSONSerialization.JSONObjectWithData(data!, options: [])print(json) 在 Swift 3 中，将移除 NS 前缀，就变成了：12345let file = Bundle.main.path(forResource: "tutorials", ofType: "json")let url = URL(fileURLWithPath: file!)let data = try! Data(contentsOf: url)let json = try! JSONSerialization.jsonObject(with: data)print(json) 除了M_PI 还有 .pi在过去，我们使用 M_PI 常量来表示 π。所以根据半径求周长代码如下：12let r = 3.0let circumference = 2 * M_PI * r 在 Swift 3 中，π 提供了 Float，Double 与 CGFloat 三种形式（Float.pi、Double.pi、CGFloat.pi），所以求周长还可以这么写：123456et r = 3.0let circumference = 2 * Double.pi * r//我们还可以将前缀省略，让其通过类型自动推断let r = 3.0let circumference = 2 * .pi * r 简化GCD的写法过去写法采用 C 语言的风格，初学者可能会不大适应。比如创建一个简单的异步线程1234let queue = dispatch_queue_create("Swift 2.2", nil)dispatch_async(queue) &#123; print("Swift 2.2 queue")&#125; Swift 3 取消了这种冗余的写法，而采用了更为面向对象的方式：1234let queue = DispatchQueue(label: "Swift 3")queue.async &#123; print("Swift 3 queue")&#125; Core Graphics的写法也更加面向对象化Core Graphics 是一个相当强大的绘图框架，但是和 GCD 一样，它原来的 API 也是 C 语言风格的。比如我们要创建一个 view，其内部背景使用 Core Graphics 进行绘制（红色边框，蓝色背景）。过去我们这么写：123456789101112131415class View: UIView &#123; override func drawRect(rect: CGRect) &#123; let context = UIGraphicsGetCurrentContext() let blue = UIColor.blueColor().CGColor CGContextSetFillColorWithColor(context, blue) let red = UIColor.redColor().CGColor CGContextSetStrokeColorWithColor(context, red) CGContextSetLineWidth(context, 10) CGContextAddRect(context, frame) CGContextDrawPath(context, .FillStroke) &#125;&#125;let frame = CGRect(x: 0, y: 0, width: 100, height: 50)let aView = View(frame: frame) 在 Swift 3 中改进了写法，只要对当前画布上下文解包，之后的所有绘制操作就都基于解包对象。123456789101112131415161718class View: UIView &#123; override func draw(_ rect: CGRect) &#123; guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125; let blue = UIColor.blue.cgColor context.setFillColor(blue) let red = UIColor.red.cgColor context.setStrokeColor(red) context.setLineWidth(10) context.addRect(frame) context.drawPath(using: .fillStroke) &#125;&#125;let frame = CGRect(x: 0, y: 0, width: 100, height: 50)let aView = View(frame: frame) 新增的访问控制关键字：fileprivate、open在 Swift 3 中在原有的 3 个访问控制关键字 private、public、internal 外。又添加了2个新关键字 fileprivate、open。它们可以看成是对原来 private 和 public 的进一步细分 一些语法的修改数组排序：sort()与sorted()过去数组排序的两个方法：sortInPlace() 和 sort()，现在分别改名成 sort() 和 sorted()sort() 是直接对目标数组进行排序。sorted() 是返回一个排序后的数组，原数组不变。12345678var array1 = [1, 5, 3, 2, 4]array1.sort()print(array1) //[1, 2, 3, 4, 5]var array2 = [1, 5, 3, 2, 4]let sortedArray = array2.sorted()print(array2) //[1, 5, 3, 2, 4]print(sortedArray) //[1, 2, 3, 4, 5] reversed()与enumerated()过去 reverse() 方法实现数组反转，enumerate() 方法实现遍历。现这两个方法都加上 ed 后缀（reversed、enumerated）12345678for i in (1...10).reversed() &#123;print(i)&#125;let array = [1, 5, 3, 2, 4]for (index, value) in array.enumerated() &#123;print("\(index + 1) \(value)")&#125; CGRect、CGPoint、CGSize过去的 CGRectMake、CGPointMake、CGSizeMake 已废弃。现改用 CGRect、CGPoint、CGSize 代替。123456789//Swift 2let frame = CGRectMake(0, 0, 20, 20)let point = CGPointMake(0, 0)let size = CGSizeMake(20, 20)//Swift 3let frame = CGRect(x: 0, y: 0, width: 20, height: 20)let point = CGPoint(x: 0, y: 0)let size = CGSize(width: 20, height: 20) 移除了API中多余的单词XCPlaygroundPage.currentPage 改为 PlaygroundPage.currentbutton.setTitle(forState) 改为 button.setTitle(for)button.addTarget(action, forControlEvents) 改为 button.addTarget(action, for) arr.minElement() 改为 arr.min()arr.maxElement() 改为 arr.max()attributedString.appendAttributedString(anotherString) 改为 attributedString.append(anotherString)names.insert(“Jane”, atIndex: 0) 改为 names.insert(“Jane”, at: 0) NSBundle.mainBundle() 改为 Bundle.mainUIDevice.currentDevice() 改为 UIDevice.currentNSData(contentsOfURL) 改为 Data(contentsOf)NSJSONSerialization.JSONObjectWithData() 改为 JSONSerialization.jsonObject(with)UIColor.blueColor() 改为 UIColor.blue 枚举成员变成小写字母开头Swift 3 将枚举成员当做属性来看，所以现在使用小写字母开头而不是以前的大写字母。1234.system //过去是：.System.touchUpInside //过去是：.TouchUpInside.fillStroke //过去是：.FillStroke.cgColor //过去是：.CGColor @discardableResult在 Swift 3 中，如果一个方法有返回值。而调用的时候没有接收该方法的返回值，Xcode 会报出警告，告诉你这可能会存在潜在问题。1234567891011121314151617181920import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() printMessage(message: "Hello Swift 3!") &#125; @discardableResult func printMessage(message: String) -&gt; String &#123; let outputMessage = "Output : \(message)" return outputMessage &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() &#125;&#125; 以上整理来自航歌个人博客,查看更全的Swift3.0新特性可访问realm]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[企业分发的项目安装使用方法]]></title>
      <url>%2F2016%2F11%2F05%2F%E4%BC%81%E4%B8%9A%E9%A1%B9%E7%9B%AE%E4%BF%A1%E4%BB%BB%2F</url>
      <content type="text"><![CDATA[由于之前做的项目有的是用企业证书打包的,走的是企业分发的通道,iOS9之后打开的时候不在有信任这一选项,所以很多用户一时还不知道该怎么设置,这里介绍一下打开企业应用的流程 原因 苹果的企业开发证书，可以不经app store,直接发布到自己的网站上。其他人可以直接下载安装。但前提要用苹果自带的浏览器（safari)才能下载，其他浏览器不能识别该协议。 由于iOS9增强了企业版开发者证书的验证规则，因此iOS9需要用户手动信任企业证书，才能正常使用。默认情况下，打开企业证书打包的app是这样的情况。 企业证书验证步骤介绍 “设置”-&gt;”通用”-&gt;”描述文件”-&gt;［找到对应的证书］-&gt;信用证书 设置步骤打开“设置” 设置 找到“通用”－“描述文件” 通用－描述文件选择对应的企业证书，如以下企业证书： 信用此证书 重新打开]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[卡片动画]]></title>
      <url>%2F2016%2F11%2F03%2F%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[现在许多应用的信息展示用到了卡片式的样式,开源代码也很多了,其主要是应用了UICollectionView的布局定制,自定义UICollectionViewFlowLayout实现的,这里具体来记录一下常见的实现过程 添加UICollectionView到界面上定义Collectionview12345678910111213func createCollectionView() &#123; collectionView = UICollectionView(frame: CGRect(x:0, y:100, width:SCREEN_WIDTH, height:200), collectionViewLayout: layout) collectionView.backgroundColor = UIColor.clear collectionView.collectionViewLayout = layout // 不显示水平方向的横条 collectionView.showsHorizontalScrollIndicator = false // 实现代理 collectionView.delegate = self collectionView.dataSource = self collectionView.register(DNViewCell.self, forCellWithReuseIdentifier: cellIdentifier) collectionView.reloadData() self.view.addSubview(collectionView)&#125; 懒加载自定义的UICollectionViewFlowLayout(稍后实现)12345678910111213lazy var layout: DNFlowLayout = &#123; let lo = DNFlowLayout() // 滚动方向 水平 lo.scrollDirection = .horizontal // 最小行间距 lo.minimumLineSpacing = 20 // 上下左右间距 lo.sectionInset = UIEdgeInsetsMake(0, LAYOUT_INSET, 0, LAYOUT_INSET) // cell大小 lo.itemSize = CGSize(width: CELL_WIDTH, height: CELL_WIDTH) return lo&#125;() 实现CollectionView代理123456789101112131415extension ViewController: UICollectionViewDelegate, UICollectionViewDataSource &#123; func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return 20; &#125; func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; let cell = self.collectionView.dequeueReusableCell(withReuseIdentifier: cellIdentifier, for: indexPath) as! DNViewCell cell.contentView.backgroundColor = UIColor.red return cell &#125; func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123; print(indexPath.item) &#125;&#125; 通过上述代码可以实现简单的collectionview展示如下 接下来,我们要实现过度动画效果,通过定制UICollectionViewFlowLayout来实现,借鉴借鉴别人写的就偷偷懒了 自定义UICollectionViewFlowLayout12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class DNFlowLayout: UICollectionViewFlowLayout &#123; override func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint) -&gt; CGPoint &#123; // 当前处理器能处理的最大浮点数 var offsetAdjustment = CGFloat(MAXFLOAT) // collectionView落在屏幕中点的x坐标 let horizontalCenter = proposedContentOffset.x + (self.collectionView!.bounds.width / 2.0) let targetRect = CGRect(x: proposedContentOffset.x, y: 0.0, width: self.collectionView!.bounds.size.width, height: self.collectionView!.bounds.size.height) // 目标区域中包含的cell let array = super.layoutAttributesForElements(in: targetRect) as [UICollectionViewLayoutAttributes]! for layoutAttributes in array!&#123; let itemHorizontalCenter = layoutAttributes.center.x //ABS求绝对值 if(abs(itemHorizontalCenter-horizontalCenter) &lt; abs(offsetAdjustment))&#123; // 比较谁离中心点更近 offsetAdjustment = itemHorizontalCenter-horizontalCenter &#125; &#125; // 返回collectionView最终停留的位置 return CGPoint(x: proposedContentOffset.x + offsetAdjustment, y: proposedContentOffset.y) &#125; // 垂直缩放除以系数 let ActiveDistance : CGFloat = 350 // 缩放系数 越大缩放越大 let ScaleFactor : CGFloat = 0.25 override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? &#123; // rect范围内的cell视图 let array = super.layoutAttributesForElements(in: rect) var visibleRect = CGRect() visibleRect.origin = self.collectionView!.contentOffset visibleRect.size = self.collectionView!.bounds.size for attributes in array!&#123; let distance = visibleRect.midX - attributes.center.x let normalizedDistance = distance/ActiveDistance let zoom = 1 - ScaleFactor*(abs(normalizedDistance)) let alpha = 1 - abs(normalizedDistance) // SX：X轴缩放 SY：Y轴缩放 attributes.transform3D = CATransform3DMakeScale(1.0, zoom, 1.0) attributes.alpha = alpha attributes.zIndex = 1 &#125; return array &#125; override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -&gt; Bool &#123; // 滑动放大缩小 需要实时刷新layout return true &#125;&#125; 实现后的效果 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[横竖屏控制]]></title>
      <url>%2F2016%2F11%2F01%2F%E6%A8%AA%E7%AB%96%E5%B1%8F%E6%8E%A7%E5%88%B6%2F</url>
      <content type="text"><![CDATA[许多应用都支持横竖屏旋转,因此就有了每个界面需要能够自由控制界面方向的需求,我们以最常见的Navi+Tabbar为例,实现该种需求 导航控制器中设置12345678910111213class DNNavigationController: UINavigationController &#123; override var shouldAutorotate: Bool &#123; return self.topViewController!.shouldAutorotate &#125; override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123; return self.topViewController!.supportedInterfaceOrientations &#125; override var preferredStatusBarStyle: UIStatusBarStyle &#123; return self.topViewController!.preferredStatusBarStyle &#125;&#125; TabBar设置123456789class DNTabBarViewController: UITabBarController &#123; override var shouldAutorotate: Bool &#123; return self.selectedViewController!.shouldAutorotate &#125; override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123; return (self.selectedViewController?.supportedInterfaceOrientations) ?? .all &#125;&#125; 在要控制的界面中实现 现在大部分应用界面还都是以竖屏为主,最好定义一个ViewController的基类,在需要支持横竖屏的类里再重写改方法 1234567override var supportedInterfaceOrientations: UIInterfaceOrientationMask &#123; return .portrait&#125;override var shouldAutorotate: Bool &#123; return true&#125; 问题 只是实现这些的话,在plus手机中可能会出现方向混乱的情况,尤其是手机横屏的时候进入,但是界面只支持竖屏,解决这一问题我们需要在应用初始化的时候定义方向,一定要在创建window之前定义 12345678910func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; // 初始化屏幕方向 UIApplication.shared.setStatusBarOrientation(.portrait, animated: true) // 创建window self.window = UIWindow(frame: UIScreen.main.bounds) self.window?.makeKeyAndVisible() self.window?.backgroundColor = UIColor.white return true&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[textField输入中文文字下沉问题]]></title>
      <url>%2F2016%2F10%2F31%2FtextField%E9%97%AE%E9%A2%98001%2F</url>
      <content type="text"><![CDATA[当我们用storyboard创建一个textfield的时候,输入中文时文字会往下偏移,输入英文时一切正常 解决其实很简单,设置一下textfield的clearButtonMode就行了1textField.clearButtonMode = .whileEditing]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode8注释失效]]></title>
      <url>%2F2016%2F10%2F29%2FXcode8%E6%B3%A8%E9%87%8A%E5%A4%B1%E6%95%88%2F</url>
      <content type="text"><![CDATA[每次升级Xcode对于插件来说都是一次灾难,总是会失效,这次Xcode8也不例外,不过类似VVDocument注释功能被苹果自己添加进来了,不用再用第三方的了 Xcode8自带的注释快捷键是单行注释: command + /多行注释: command + option + / 下图绿框中的为注释相关设置 如何修改快捷键如果觉得默认注释快捷键不是自己喜欢的组合,则可以自己改,比如我把它修改成shift + / 其是就是 ? 问题在使用注释快捷键的时候可能会弹出警告如下图这个通常是xcode不知道你要给谁添加注释,比如你要给一个方法添加注释,但是光标位置跟方法空了一行等]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法 Swift]]></title>
      <url>%2F2016%2F10%2F27%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-Swift%2F</url>
      <content type="text"><![CDATA[在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法,这里总结几个常用算法的写法,包括冒泡排序,快速排序,插入排序,选择排序. 冒泡排序12345678910111213func bubbleSort&lt;T: Comparable&gt; (oArr: [T]) -&gt; [T] &#123; var arr = oArr for outerIndex in (1...arr.count - 1).reversed() &#123; for innerIndex in 0..&lt;outerIndex &#123; if arr[innerIndex] &gt; arr[innerIndex + 1] &#123; let temp = arr[innerIndex] arr[innerIndex] = arr[innerIndex + 1] arr[innerIndex + 1] = temp &#125; &#125; &#125; return arr&#125; 快速排序123456789101112131415161718extension Array &#123; var decompose : (head: Element, tail: [Element])? &#123; return (count &gt; 0) ? (self[0], Array(self[1..&lt;count])) : nil &#125;&#125;func quickSort&lt;T: Comparable&gt; (oArr: [T]) -&gt; [T] &#123; let arr = oArr if let (pivot, rest) = arr.decompose &#123; let lesser = rest.filter &#123; $0 &lt; pivot &#125; let greater = rest.filter &#123; $0 &gt;= pivot &#125; let les = quickSort(oArr: lesser) let gre = quickSort(oArr: greater) return les + [pivot] + gre &#125; else &#123; return [] &#125;&#125; 插入排序12345678910111213func insertionSort&lt;T: Comparable&gt; (oArr: [T]) -&gt; [T] &#123; var arr = oArr for outerIndex in 1..&lt;arr.count &#123; let temp = arr[outerIndex] var innerIndex = outerIndex while innerIndex &gt; 0 &amp;&amp; arr[innerIndex - 1] &gt;= temp &#123; arr[innerIndex] = arr[innerIndex - 1] innerIndex -= 1 &#125; arr[innerIndex] = temp &#125; return arr&#125; 选择排序123456789101112131415161718func selectSort&lt;T: Comparable&gt; (oArr: [T]) -&gt; [T] &#123; var arr = oArr var minIndex = 0 // 记录每次遍历的最小值位置 for outerIndex in 0..&lt;arr.count &#123; minIndex = outerIndex for innerIndex in (outerIndex + 1)..&lt;arr.count &#123; if arr[minIndex] &gt; arr[innerIndex] &#123; minIndex = innerIndex // 判断最小值,记住下表 &#125; if minIndex != outerIndex &#123; let temp = arr[outerIndex] arr[outerIndex] = arr[minIndex] arr[minIndex] = temp &#125; &#125; &#125; return arr&#125; 更多的排序算法可以去百科看看]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift常用三方库]]></title>
      <url>%2F2016%2F10%2F25%2FSwift%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
      <content type="text"><![CDATA[开发应用最不缺的就是轮子,尤其是懒得写某个效果或者功能的时候都可以拿前人写好的三方库快速开发,总结一下新项目可能会用到的三方库 常用三方库网络请求 Alamofire : 小星星最多的网络请求库,支持iOS9以上版本,与AFNetworking同源SwiftHTTP : 又是一个好用的网络请求库,支持iOS8以上版本Just : 无意中发现的但是蛮好用的,支持iOS8以上版本 钥匙串 KeychainAccess : 用这东西记录用户名密码之类的挺方便的,用法也比较简单,支持iOS8以上版本 图片加载 Kingfisher : 图片加载中星星最高的库,支出iOS8.0以上版本 JSON解析 SwiftyJSON : JSON数据解析利器,不用手动层层解包了,支持iOS8以上版本 视图布局 SnapKit : 代码布局首选,与Masonry同源,支持iOS8以上版本 指示器 NVActivityIndicatorView : 一大堆样式可以选 本地存储 SQLite.swift : swift中星星最高的存储库,支持iOS7以上版本SwiftyUserDefaults : 在swift中用NSUserDefaults存储数据 控制台打印 XCGLogger : 花花绿绿五颜六色的打印结果最好看了,支持iOS8以上版本 相机相册图片 ImagePicker : 非常精致的一个图片选择器SKPhotoBrowser : 图片查看库 扩展类 EZSwiftExtensions : 整理的真心多 提示框 SweetAlert-iOS : 带动画的弹框,调用也简单,效果不错,支持iOS7以上版本SwiftMessages : 消息提示,到处都可以显示的横条,效果非常不错 内购 SwiftyStoreKit : 省心省时省力,内购封装 皮肤主题 SwiftTheme : 主题/换肤, 夜间模式,支持iOS7以上版本 二维码扫描 QRCodeReaderView-Swift : 基于swift语言实现二维码条形码扫描,本地相册二维码识别 指纹和手势密码 TouchIDAndGestureLock : 指纹解锁、手势解锁 通讯录 PPGetAddressBookSwift : 获取通讯录并排序 提示框 SweetAlert-iOS : 动画提示框]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cocoapods使用]]></title>
      <url>%2F2016%2F10%2F23%2Fcocoapods%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[最为iOS开发的一般都知道cocoapods,在管理三方库方面还是减少不少麻烦的,之前一直用的老版本的cocoapods,升级到1.0以上版本后,写法有所改变,再总结一下用法 创建项目CocoapodsDemo 用Xcode创建CocoapodsDemo项目,并设置支持的最低版本 添加Podfile文件cd到刚创建的项目的根目录下创建Podfile $ pod init 这时候查看项目文件夹会发现多出一个Podfile文件 打开该文件终端执行命令 $ vim Podfile或者$ open -e podfile 更推荐后者,vim编辑真心难用,需要一行一样的跳打开后我们会看到里面已经为我们创建了不少东西,省的自己写了 把碍眼的注释都删掉如果你在创建应用的时候勾选了Tests和UITest,则会同时创建出他们对应的target,我们暂时不用,也直接删了就行了,什么时候用到什么时候在加上这就顺眼多了 添加需要的三方库以添加Alamofire为例 首先查看Alamofire目前的版本,有三种 1.去github上看看文档介绍2.去Cocoapods官网上查查文档3.在终端上通过命令查询 $ pod search alamofire 前两者都能查到最新版本,第三种有可能查不到最新的,需要更新本地库 $ pod repo update 接下来按照查询到的方法在Podfile中书写 关闭编辑页面 拉取三方库资源 $ pod install 这时候打开项目文件,会发现多出了几个文件 打开.workspace文件即可看到多处了一Pods工程 以后要是需要更新三方库只需要执行命令 $ pod update 到这里cocoapods使用就结束了 接下来项目要是需要用到Pods里的三方库只需要引用头文件就能用了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cocoapods升级]]></title>
      <url>%2F2016%2F10%2F21%2Fcocoapods%E5%8D%87%E7%BA%A7%2F</url>
      <content type="text"><![CDATA[swift3.0许多库对cocoapods的版本也有要求,这使得我们不得不升级cocoapods,由于手边项目较多,一直没升级cocoapods,主要是懒得改,这次有时间了,就把它给升了吧. 切换gem源 $ gem sources –remove https://rubygems.org/$ gem source -a https://gems.ruby-china.org/ 查看是否切换成功 $ gem source -l 当现实为下图则为成功 升级cocoapods $ sudo gem install -n /usr/local/bin cocoapods或者试试下面的命令,这是更新推荐提示的命令$ sudo gem install cocoapods –pre 这时候会出现一大堆输出等结束 查看版本 $ pod –version 欧 买噶的,居然没有更新 不用紧张,可能是gem太老了,更新一下 $ gem update –system 估计得等一会,然后又输出一大堆东西等结束 再次执行 $ sudo gem install -n /usr/local/bin cocoapods$ pod –version 看到下面输出结果 ~~泪奔啊终于更新了 好了升级完成,接下来更新本地库,耐心等待即可 $ pod repo update 更新完之后可能会出现 CocoaPods 1.2.0.beta.1 is available. 这是发现还有新版本,不过是beta版本,要不要再升级,如果要就按照它提示的命令执行,否则就不用管它,beta一般就不升了,毕竟不是正式版,难免会有一些BUG]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[随机数]]></title>
      <url>%2F2016%2F10%2F19%2F%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
      <content type="text"><![CDATA[取10以内随机数arc4random() % 10 据说arc4random在32位iPhone上有时程序崩溃,用arc4random_uniform也行12let maxValue: UInt32 = 10print(Int(arc4random_uniform(maxValue))) 封装一下去随机数的方法1234func randomInRange(range: CountableClosedRange&lt;Int&gt;) -&gt; Int &#123; let count = UInt32(range.upperBound - range.lowerBound) return Int(arc4random_uniform(count)) + range.lowerBound&#125; 调用12取1到10之间的随机数randomInRange(range: (1...10)) 返回随机颜色12345678910extension UIColor &#123; open class var randomColor: UIColor&#123; get &#123; let red = CGFloat(arc4random()%256)/255.0 let green = CGFloat(arc4random()%256)/255.0 let blue = CGFloat(arc4random()%256)/255.0 return UIColor(red: red, green: green, blue: blue, alpha: 1.0) &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[本地化存储之SQLite.swift使用]]></title>
      <url>%2F2016%2F10%2F17%2F%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%AD%98%E5%82%A8%E4%B9%8BSQLite-swift%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[本地存储功能是APP常用功能,也是必备技能,OC时代,我们有很好用的FMDB三方库可以轻松实现本地化存储,Swift同样有不错的替代品,这里主要介绍的是SQLite.swift三方库,用起来也是很简单,这里以存储用户信息为例. 创建数据库文件1234567891011121314151617mutating func createdsqlite3() &#123; // 设置数据库路径 let sqlFilePath = NSHomeDirectory() + "/Documents/usersinfodb.sqlite3" do &#123; db = try Connection(sqlFilePath) try db.run(users.create(block: &#123; (table) in table.column(id, primaryKey: true) table.column(username) table.column(userage) table.column(usersex) table.column(userid) table.column(useremail) &#125;)) &#125; catch &#123; print("创建数据库出错: \(error)") &#125;&#125; 添加用户信息1234567891011121314151617181920212223242526func insertUser(userModel: DNUsersModel) &#123; // 用户信息中没有ID就不存入数据库(被列为无效用户) guard let userId = userModel.userid else &#123; print("没有ID信息,视为无效用户") return; &#125; // 查找数据库中是否有该用户,如果有则执行修改操作 guard readUser(userId: userId) == nil else &#123; print("已存在改用户,接下来更新此用户数据") updateUser(userId: userId, userModel: userModel) return &#125; let insert = users.insert(username &lt;- userModel.username, userage &lt;- userModel.userage, usersex &lt;- userModel.usersex, userid &lt;- userModel.userid, useremail &lt;- userModel.useremail) do &#123; let num = try db.run(insert) print(num) &#125; catch &#123; print("增加用户到数据库出错: \(error)") &#125;&#125; 删除指定用户信息123456789func deleteUser(userId: String) &#123; let currUser = users.filter(userid == userId) do &#123; let num = try db.run(currUser.delete()) print(num) &#125; catch &#123; print("删除用户信息出错: \(error)") &#125;&#125; 更新指定用户信息1234567891011121314func updateUser(userId: String, userModel: DNUsersModel) &#123; let currUser = users.filter(userid == userId) let update = currUser.update(username &lt;- userModel.username, userage &lt;- userModel.userage, usersex &lt;- userModel.usersex, userid &lt;- userModel.userid, useremail &lt;- userModel.useremail) do &#123; let num = try db.run(update) print(num) &#125; catch &#123; print(error) &#125;&#125; 更新用户名12345678910func updateUser(userId: String, userName: String) &#123; let currUser = users.filter(userid == userId) let update = currUser.update(username &lt;- userName) do &#123; let num = try db.run(update) print(num) &#125; catch &#123; print(error) &#125;&#125; 查询指定用户信息1234567891011121314func readUser(userId: String) -&gt; DNUsersModel? &#123; var userModel: DNUsersModel? = DNUsersModel() for user in try! db.prepare(users) &#123; if user[userid] == userId &#123; userModel?.username = user[username] userModel?.userage = user[userage] userModel?.usersex = user[usersex] userModel?.userid = user[userid] userModel?.useremail = user[useremail] return userModel &#125; &#125; return nil&#125; 查询所有用户信息12345678910111213func readAllUsers() -&gt; [DNUsersModel]? &#123; var usersArr: [DNUsersModel]? = [DNUsersModel]() var userModel: DNUsersModel? = DNUsersModel() for user in try! db.prepare(users) &#123; userModel?.username = user[username] userModel?.userage = user[userage] userModel?.usersex = user[usersex] userModel?.userid = user[userid] userModel?.useremail = user[useremail] usersArr?.append(userModel!) &#125; return usersArr&#125; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML速查表]]></title>
      <url>%2F2016%2F10%2F15%2FHTML%E9%80%9F%E6%9F%A5%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[HTML 是一种在 Web 上使用的通用标记语言。HTML 允许你格式化文本，添加图片，创建链接、输入表单、框架和表格等等，并可将之存为文本文件，浏览器即可读取和显示。 HTML 基本文档1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;文档标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 可见文本... &lt;/body&gt;&lt;/html&gt; 基本标签（Basic Tags）1234567891011&lt;h1&gt;最大的标题&lt;/h1&gt;&lt;h2&gt; . . . &lt;/h2&gt;&lt;h3&gt; . . . &lt;/h3&gt;&lt;h4&gt; . . . &lt;/h4&gt;&lt;h5&gt; . . . &lt;/h5&gt;&lt;h6&gt;最小的标题&lt;/h6&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;br&gt; （换行）&lt;hr&gt; （水平线）&lt;!-- 这是注释 --&gt; 文本格式化（Formatting）123456789101112131415161718&lt;b&gt;粗体文本&lt;/b&gt;&lt;code&gt;计算机代码&lt;/code&gt;&lt;em&gt;强调文本&lt;/em&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;kbd&gt;键盘输入&lt;/kbd&gt; &lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;small&gt;更小的文本&lt;/small&gt;&lt;strong&gt;重要的文本&lt;/strong&gt;&lt;abbr&gt; （缩写）&lt;address&gt; （联系信息）&lt;bdo&gt; （文字方向）&lt;blockquote&gt; （从另一个源引用的部分）&lt;cite&gt; （工作的名称）&lt;del&gt; （删除的文本）&lt;ins&gt; （插入的文本）&lt;sub&gt; （下标文本）&lt;sup&gt; （上标文本） 链接（Links）123456普通的链接： &lt;a href=" 链接文本&lt;/a&gt; 图像链接： &lt;a href="http://www.example.com/"&gt;&lt;img src="URL" alt="替换文本"&gt;&lt;/a&gt; 邮件链接： &lt;a href="mailto:webmaster@example.com"&gt;发送e-mail&lt;/a&gt;书签： &lt;a id="tips"&gt;提示部分&lt;/a&gt; &lt;a href="#tips"&gt;跳到提示部分&lt;/a&gt; 图片（Images）1&lt;img src="URL" alt="替换文本" height="42" width="42"&gt; 样式/区块（Styles/Sections）12345678&lt;style type="text/css"&gt; h1 &#123;color:red;&#125; p &#123;color:blue;&#125;&lt;/style&gt;&lt;div&gt;文档中的块级元素&lt;/div&gt;&lt;span&gt;文档中的内联元素&lt;/span&gt; 无序列表1234&lt;ul&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt;&lt;/ul&gt; 有序列表1234&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt; 自定义列表123456&lt;dl&gt; &lt;dt&gt;项目 1&lt;/dt&gt; &lt;dd&gt;描述项目 1&lt;/dd&gt; &lt;dt&gt;项目 2&lt;/dt&gt; &lt;dd&gt;描述项目 2&lt;/dd&gt;&lt;/dl&gt; 表格（Tables）12345678910&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 框架（Iframe）1&lt;iframe src="demo_iframe.htm"&gt;&lt;/iframe&gt; 表单（Forms）12345678910111213141516171819&lt;form action="demo_form.php" method="post/get"&gt;&lt;input type="text" name="email" size="40" maxlength="50"&gt; &lt;input type="password"&gt; &lt;input type="checkbox" checked="checked"&gt; &lt;input type="radio" checked="checked"&gt; &lt;input type="submit" value="Send"&gt; &lt;input type="reset"&gt; &lt;input type="hidden"&gt; &lt;select&gt; &lt;option&gt;苹果&lt;/option&gt; &lt;option selected="selected"&gt;香蕉&lt;/option&gt; &lt;option&gt;樱桃&lt;/option&gt; &lt;/select&gt;&lt;textarea name="comment" rows="60" cols="20"&gt;&lt;/textarea&gt; &lt;/form&gt; 实体（Entities）123&amp;lt; 等同于 &lt;&amp;gt; 等同于 &gt;© 等同于 ©]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode8去除多余打印]]></title>
      <url>%2F2016%2F10%2F13%2FXcode8%E5%8E%BB%E9%99%A4%E5%A4%9A%E4%BD%99%E6%89%93%E5%8D%B0%2F</url>
      <content type="text"><![CDATA[打开路径 Product -&gt; Scheme -&gt; Edit Scheme 配置内容 OS_ACTIVITY_MODE=disable]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode8 权限配置]]></title>
      <url>%2F2016%2F10%2F11%2FXcode8-%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[iOS10之后加强了权限管理,在使用某项系统权限的时候需要在plist中配置,如果不配置,在上传项目之后构建版本在itunes connect里可能看不到,审核也可能被拒 相机权限 Privacy - Camera Usage Description 是否允许此App使用你的相机 相册权限 Privacy - Photo Library Usage Description 是否允许此App访问你的媒体资料库 定位权限 Privacy - Location When In Use Usage Description 我们需要通过您的地理位置信息获取您周边的相关数据 Privacy - Location Always Usage Description 我们需要通过您的地理位置信息获取您周边的相关数据 通讯录权限 Privacy - Contacts Usage Description 是否允许此App访问你的通讯录 麦克风权限 Privacy - Microphone Usage Description 是否允许此App使用你的麦克风 蓝牙权限 Privacy - Bluetooth Peripheral Usage Description 是否许允此App使用蓝牙 语音转文字权限 Privacy - Speech Recognition Usage Description 是否允许此App使用语音识别 日历权限 Privacy - Calendars Usage Description 是否允许此App使用日历]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[地理定位]]></title>
      <url>%2F2016%2F10%2F09%2F%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%2F</url>
      <content type="text"><![CDATA[现在的app基本上都有定位功能,又得是获取左边和城市信息,又得是地图展示,这里介绍获取简单的地理位置信息功能,包括坐标,所在城市等基本信息. 添加依赖库 导入头文件12345678CoreLocation.frameworkimport CoreLocation// 别忘了在plist中添加隐私权限Privacy - Location Always Usage DescriptionPrivacy - Location When In Use Usage Description都是String类型 后面描述: 我们需要通过您的地理位置信息获取您周边的相关数据 初始化相关对象123456789101112131415// 创建一个CLLocationManager对象private var locationManager: CLLocationManager!// 创建一个CLGeocoder对象private var geocoder: CLGeocoder!// 初始化locationManagerlocationManager = CLLocationManager()locationManager.delegate = selflocationManager.desiredAccuracy = kCLLocationAccuracyBest //定位精准度locationManager.distanceFilter = 100 // 超出范围更新位置信息if Double(UIDevice.current.systemVersion)! &gt;= 8.0 &#123; locationManager.requestWhenInUseAuthorization() // 使用期间&#125;// 初始化geocodergeocoder = CLGeocoder() 开始定位1locationManager.startUpdatingLocation() 添加代理并实现代理方法123456789101112131415161718192021222324252627282930313233343536373839CLLocationManagerDelegatefunc locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) &#123; print("每当请求到位置信息时都会调用此方法") if let location = locations.first &#123; // 坐标 print(location) geocoder.reverseGeocodeLocation(location) &#123; (placemarks, error) in if let placemark = placemarks?.first &#123; print(placemark.locality) &#125; &#125; &#125; &#125; // 不需要定位的时候停止定位 manager.stopUpdatingLocation()&#125;func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) &#123; print("定位失败: %@", error)&#125;func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) &#123; switch status &#123; case .notDetermined: print("用户未决定") case .restricted: // 暂时没啥用 print("访问受限") case .denied: // /定位关闭时和对此APP授权为never时调用 if CLLocationManager.locationServicesEnabled() &#123; print("定位开启,但被拒绝") &#125; else &#123; print("定位关闭,不可用") &#125; case .authorizedAlways: print("获取前后台定位授权") case .authorizedWhenInUse: print("获取前台定位授权") &#125;&#125; 为了提高用户体验,通常当检测到用户为打开定位功能的时候让用户便捷跳转到设置界面123456789101112131415161718192021222324if let settingUrl = URL(string: UIApplicationOpenSettingsURLString) &#123; if UIApplication.shared.canOpenURL(settingUrl) &amp;&amp; Double(UIDevice.current.systemVersion)! &gt;= 8.0 &#123; //iOS8可直接跳转到设置界面 let alertVC = UIAlertController(title: "提示", message: "定位功能被拒绝，是否前往设置开启", preferredStyle: .alert) let cancelAction = UIAlertAction(title: "取消", style: .cancel, handler: &#123; (action) in &#125;) let okAction = UIAlertAction(title: "确定", style: .default, handler: &#123; (action) in UIApplication.shared.openURL(settingUrl) &#125;) alertVC.addAction(cancelAction) alertVC.addAction(okAction) let vc = UIApplication.shared.keyWindow?.rootViewController vc?.present(alertVC, animated: true, completion: nil) &#125; else &#123; let alertVC = UIAlertController(title: "提示", message: "定位服务未开启\n打开方式:设置-&gt;隐私-&gt;定位服务", preferredStyle: .alert) let cancelAction = UIAlertAction(title: "确定", style: .cancel, handler: &#123; (action) in &#125;) alertVC.addAction(cancelAction) let vc = UIApplication.shared.keyWindow?.rootViewController vc?.present(alertVC, animated: true, completion: nil) &#125;&#125; 下载源码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[系统声音服务的使用]]></title>
      <url>%2F2016%2F10%2F07%2F%E7%B3%BB%E7%BB%9F%E5%A3%B0%E9%9F%B3%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[系统声音服务(System Sound Services)提供了一个接口，用于播放不超过30秒的声音。它支持的文件格式有限，具体地说只有CAF、AIF和使用PCM或IMA/ADPCM数据的WAV文件。由于这些函数没有提供操纵声音和控制音量的功能，所以当你为多媒体或者游戏创建专门的配乐时，不要使用系统声音服务。 系统声音服务的使用(播放声音,提醒,震动)系统声音服务要求 1.系统声音播放不能超过30s2.允许格式: CAF AIF 和使用PCM IMA/ADPCM数据的WAV文件 支持三种类型 1.声音: 立即播放一个简单声音,手机静音则什么声音都没有2.提醒: 播放一个声音文件如果手机设为静音或震动，则通过震动提醒用户3.震动: 震动手机，而不考虑其他设置 注意事项: 导入音频文件之后,有时候会出现Bundle.main.path(forResource: sound, ofType: type) 这个方法获取不到资源的问题原因: xcode没有自动将文件添加到你的资源文件中解决: build Phases中的 copy Bundle Resources中点击”+”手动添加资源文件 使用方法导入头文件1import AudioToolbox 声音播放1234567891011func playAlertSound(sound: String, type: String) &#123; // 建立sysytemSoundID对象 var soundID: SystemSoundID = 0 // 获取声音地址 guard let soundPath = Bundle.main.path(forResource: sound, ofType: type) else &#123; return &#125; guard let soundUrl = NSURL(string: soundPath) else &#123; return &#125; // 赋值 AudioServicesCreateSystemSoundID(soundUrl, &amp;soundID) // 播放声音 AudioServicesPlaySystemSound(soundID)&#125; 提醒1234567891011func playSystemAlert(sound: String, type: String) &#123; // 建立sysytemSoundID对象 var soundID: SystemSoundID = 0 // 获取声音地址 guard let soundPath = Bundle.main.path(forResource: sound, ofType: type) else &#123; return &#125; guard let soundUrl = NSURL(string: soundPath) else &#123; return &#125; // 赋值 AudioServicesCreateSystemSoundID(soundUrl, &amp;soundID) // 提醒（同播放声音唯一的一个区别） AudioServicesPlayAlertSound(soundID)&#125; 震动1234// 建立的SystemSoundID对象let soundID = SystemSoundID(kSystemSoundID_Vibrate)// 振动AudioServicesPlaySystemSound(soundID) 防止出现重复点击声音覆盖 通常我们会在上一个声音播放完成之后才会调用下一次播放这里就会用到完成的回调方法 AudioServicesAddSystemSoundCompletion 例:123456789101112131415161718192021222324func playAlertSound(sound: String, type: String) &#123; if !isPlaying &#123; isPlaying = true // 建立sysytemSoundID对象 var soundID: SystemSoundID = 0 // 获取声音地址 guard let soundPath = Bundle.main.path(forResource: sound, ofType: type) else &#123; return &#125; guard let soundUrl = NSURL(string: soundPath) else &#123; return &#125; // 赋值 AudioServicesCreateSystemSoundID(soundUrl, &amp;soundID) // 播放声音 AudioServicesPlaySystemSound(soundID) // 播放完成回调 let pointer = Unmanaged.passUnretained(self).toOpaque() AudioServicesAddSystemSoundCompletion(soundID, nil, nil, &#123; (soundID, pointer) in print("播放完成") let mySelf = Unmanaged&lt;ViewController&gt;.fromOpaque(pointer!).takeUnretainedValue() mySelf.isPlaying = false AudioServicesRemoveSystemSoundCompletion(soundID) AudioServicesDisposeSystemSoundID(soundID) &#125;, pointer) &#125;&#125; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[指纹解锁]]></title>
      <url>%2F2016%2F10%2F05%2F%E6%8C%87%E7%BA%B9%E8%A7%A3%E9%94%81%2F</url>
      <content type="text"><![CDATA[指纹识别是从iPhone 5s开始支持的,在日常使用中,可以用来解锁手机和软件内部验证等用途,这里介绍的是在软件内部的使用,现在市面上应用的指纹解锁的应用还是很多的,尤其以金钱交易类的应用作为快捷登录和支付来使用,例如支付宝,招商银行等. 这里具体讲解一下如何使用指纹识别技术解锁应用 添加依赖库 引用头文件1234LocalAuthentication.frameworkimport LocalAuthentication 实现指纹识别方法1234567891011121314151617181920212223242526func LocalAuthenticationLogin() &#123; // 本地认证上下文联系对象 let context = LAContext() var error: NSError? // 判断设备是否具备指纹认证功能 if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &amp;error) &#123; print("可以指纹识别了") context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: "验证指纹以确认您的身份", reply: &#123; (success, error) in if success &#123; print("指纹验证成功") DispatchQueue.main.async &#123; //更新UI 必须在主线程中更新,否则天知道要到猴年马月能执行 &#125; &#125; else &#123; print("指纹验证失败 错误原因:\(error)") let errorMessage = self.errorMessageForError(aerror: error) print(errorMessage) &#125; &#125;) &#125; else &#123; let errorMessage = self.errorMessageForError(aerror: error) print(errorMessage) &#125;&#125; 归纳验证错误原因123456789101112131415161718192021222324252627282930313233func errorMessageForError(aerror: Error?) -&gt; String &#123; var errorMessage = "" if let error = aerror as? NSError &#123; switch error.code &#123; case LAError.authenticationFailed.rawValue: errorMessage = "身份验证不成功" case LAError.userCancel.rawValue: errorMessage = "手动取消验证" case LAError.userFallback.rawValue: errorMessage = "使用密码登录" case LAError.systemCancel.rawValue: errorMessage = "身份验证被系统取消" case LAError.passcodeNotSet.rawValue: errorMessage = "没有设置密码" case LAError.touchIDNotAvailable.rawValue: errorMessage = "设备不支持指纹" case LAError.touchIDNotEnrolled.rawValue: errorMessage = "没有登记的手指触摸ID" default: errorMessage = "" &#125; if #available(iOS 9.0, *)&#123; if error.code == LAError.touchIDLockout.rawValue &#123; errorMessage = "TouchID被锁" &#125; else if error.code == LAError.appCancel.rawValue &#123; errorMessage = "认证被取消应用程序" &#125; else if error.code == LAError.invalidContext.rawValue &#123; errorMessage = "调用之前已经失效" &#125; &#125; &#125; return errorMessage&#125; 当TouchID被锁 5次验证失败之后TouchID会被锁死,无法再调起指纹识别,这时候我们需要调起系统密码输入界面输入密码来重现验证指纹功能 123456789101112131415@available(iOS 9.0, *)func alertSystemPasswordView() &#123; // 本地认证上下文联系对象 let context = LAContext() var error: NSError? if context.canEvaluatePolicy(.deviceOwnerAuthentication, error: &amp;error) &#123; context.evaluatePolicy(.deviceOwnerAuthentication, localizedReason: "通过Home键验证已有手机指纹", reply: &#123; (success, error) in if success &#123; print("重设成功") &#125; else &#123; print("重设失败") &#125; &#125;) &#125;&#125; 源码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[内购退款流程]]></title>
      <url>%2F2016%2F10%2F03%2F%E5%86%85%E8%B4%AD%E9%80%80%E6%AC%BE%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[苹果提供购买后返回的流程,一般不管什么原因,90天内一般都能退款,下面介绍一下具体退款流程 1.打开itunes 手机连接电脑,打开itunes软件,在三个点中选择应用的选项 2.打开账号记录 3.选择购买历史记录 4.选择问题报告可查看订单号或者退款 APP内购因为存在退款问题,而苹果没有实时的退款通知,也导致了很多刷单的情况,比如游戏中购买道具,通过充值-退款的反复操作刷道具,这也是做苹果内购最头疼的时,不过对于消费者来说还是不要随便刷单,一经发现有故意退款的情况,以后就很难再通过退款,这属于个人信用问题,不过,如果是正常的退款则没有影响]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo建站]]></title>
      <url>%2F2016%2F10%2F01%2Fhexo%E5%BB%BA%E7%AB%99%2F</url>
      <content type="text"><![CDATA[hexo可以方便的建立个人博客,托管在github上免费建立个人博客 准备工作配置环境 Node.js Git 安装后的显示 安装hexo1$ npm install -g hexo-cli 给我们的Blog创建一个文件夹 1$ hexo init 继续执行 12$ hexo g$ hexo s --debug 执行完后,在浏览器中打开 http://localhost:4000/显示默认主题 安装主题以NexT主题为例下载 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用 NexT 主题 更新主题12cd themes/next$ git pull origin master 打开站点配置文件_config.yml,找到theme,将landscape替换成next 执行 12$ hexo clean$ hexo s --debug 可以看到如下界面 要部署到github上的时候执行 123$ hexo clean$ hexo g$ hexo d 有时候会出现错误 ERROR Deployer not found: git 这时候我们需要执行 1$ npm install hexo-deployer-git --save 然后在重新执行部署到github的操作 更多样式配置可查看 这里 绑定个人域名购买域名并实名制配置域名解析添加域名解析链接到github构建的博客上 github上配置配置hexo 在source中新建文本文件 命名CNAME,并且写入内容(要绑定的个人域名, 如:www.wjneng.com) 同步hexo之后在setting中查看是否修改成功]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[定律,定理,定则,公理,原理区别]]></title>
      <url>%2F2016%2F10%2F01%2F%E5%AE%9A%E5%BE%8B-%E5%AE%9A%E7%90%86-%E5%AE%9A%E5%88%99-%E5%85%AC%E7%90%86-%E5%8E%9F%E7%90%86%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[定律 定律是为实践和事实所证明，反映事物在一定条件下发展变化的客观规律的论断。例如牛顿运动定律、能量守恒定律、欧姆定律等。定律是一种理论模型，它用以描述特定情况、特定尺度下的现实世界，在其它尺度下可能会失效或者不准确。没有任何一种理论可以描述宇宙当中的所有情况，也没有任何一种理论可能完全正确。 定理 已经证明具有正确性、可以作为原则或规律的命题或公式，如几何定理。定理是从真命题（公理或其他已被证明的定理）出发，经过受逻辑限制的演绎推导，证明为正确的结论，即另一个真命题。例如“平行四边形的对边相等”就是平面几何中的一个定理。一般来说，在数学中，只有重要或有趣的陈述才叫定理。证明定理是数学的中心活动。相信为真但未被证明的数学叙述为猜想，当它被证明为真后便是定理。它是定理的来源，但并非唯一来源。一个从其他定理引伸出来的数学叙述，可以不经过证明成为猜想的过程，成为定理。定理已经证明具有正确性、可作为原则或规律的命题或公式。例如：“平行四边形对边相等”就是儿何学中的一个定理。 定则 公认的一种用以表达事物间内在联系的力一法，其目的是帮助理解及记忆。最常见的如右手定则，左手定则，安培螺旋法则等。 公理 经过人类长期反复的实践检验是真实的，不需要由其他判断加以证明的命题和原理。即目前大家都认可的，一定成立的命题。如传统形式逻辑三段论关于一类事物的全部是什么或不是什么，那么这类事物中的部分也是什么或不是什么，也即如果对一类事物的全部有所断定，那么对它的部分也就有所断定，便是公理。又如日常生活中人们所使用的“有生必有死”，”平面内过两点的直线有且只有一条。”也属于这种不证自明的判断。 原理 自然科学和社会科学中具有普遍意义的基本规律。是在大量观察、实践的基础上，经过归纳、概括而得出的。既能指导实践，又必须经受实践的检验。换句话说，指文字原来的理由,最基础,最根本的理论，或指某一领域或学科中带有普遍性的、最基本的、可以作为其他规律的基础的规律。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F10%2F01%2FHello-World%2F</url>
      <content type="text"><![CDATA[最近闲的蛋疼,开个博客玩玩. 这个博客是干什么的 其实主要是记录一下在开发过程中总结一些经验,和遇到的一些问题,到时候回头忘掉了还可以在翻翻看,同时也督促自己每天梳理一下知识点,省的闲的没事干什么都忘了,这里有自己的总结,也有看到别人写的好的代码总结,反正就是总结 为什么开通这个博客 好多分享平台都不错,之前在CSDN,简书等都开过博客,我为什么还要再费时费力的自己搭建博客呢,就一个原因,我想起的名字各个平台基本上都被占用的,在这里,我爱起什么名字就起什么名字,就是这么任性. 怎么对待这个博客 争取每天都能分享一点,只要有意义的都可以,日积月累就会有更多的内容值得自己去回味反思.里面的内容有些是自己日常开发所涉及的,有些是从前人总结中摘录的,如有什么雷同问题,不用惊讶,多半是从别人那抄来的,只为笔记一下,省的以后忘了 注意 本博客是搭建在GitHub上的,域名也是原始域名,没有钱买域名了😭, 就这样吧,有些内容里面的链接什么的可能需要科学上网才能访问,这个相信生活在天朝的人们都会的]]></content>
    </entry>

    
  
  
</search>
